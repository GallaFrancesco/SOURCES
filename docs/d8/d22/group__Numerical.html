<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GreatSPN: Numerical</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GreatSPN
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Numerical</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d61/structscc__node.html">scc_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d36/structdfs__visit__node.html">dfs_visit_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dc9/classBSCC.html">BSCC</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../de/dc9/classBSCC.html" title="BSCC analysis of a Markov chain. ">BSCC</a> analysis of a Markov chain.  <a href="../../de/dc9/classBSCC.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d21/structSccIndexTo0BasedIndexWithTransients.html">SccIndexTo0BasedIndexWithTransients</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d52/structAx__Residual.html">Ax_Residual&lt; Matrix &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0a/structxA__Residual.html">xA_Residual&lt; Matrix &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d79/structApId__Residual.html">ApId_Residual&lt; Matrix, VectorD &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/db1/classmatrix__map.html">matrix_map&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intermediate class that implements a matrix-like interface for filling a matrix in sparse order, and for compressing it at the end.  <a href="../../d4/db1/classmatrix__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dfc/classmultiorder__vector.html">multiorder_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d2/d88/classA.html">A</a> vector of doubles that can hold data with different magnitude orders, avoiding underflows.  <a href="../../d7/dfc/classmultiorder__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/da5/structFoxGlynnWeights.html">FoxGlynnWeights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auxiliary structures for the Fox-Glynn algorithm implementation.  <a href="../../d0/da5/structFoxGlynnWeights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d05/structPreconditioner.html">Preconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base <a class="el" href="../../d0/d05/structPreconditioner.html" title="Base Preconditioner Interface. ">Preconditioner</a> Interface.  <a href="../../d0/d05/structPreconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/de5/structNullPreconditioner.html">NullPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Null (identity) <a class="el" href="../../d0/d05/structPreconditioner.html" title="Base Preconditioner Interface. ">Preconditioner</a> Interface.  <a href="../../d0/de5/structNullPreconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d43/structqentry__comp.html">qentry_comp&lt; T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d01/structILU__Precond.html">ILU_Precond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d05/structPreconditioner.html" title="Base Preconditioner Interface. ">Preconditioner</a> class for all the ILU-like preconditioner matrices.  <a href="../../d8/d01/structILU__Precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dd0/structDiag__Precond.html">Diag_Precond</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="../../d0/d05/structPreconditioner.html" title="Base Preconditioner Interface. ">Preconditioner</a> class for a Diagonal/Jacobi preconditioner.  <a href="../../de/dd0/structDiag__Precond.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/df2/classfull__element__selector.html">full_element_selector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d27/classsubset__element__selector.html">subset_element_selector&lt; T, comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d8b/classBaseSubsetList.html">BaseSubsetList&lt; CONV, SUBSET, STATE &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dbd/classsubset__selector.html">subset_selector&lt; Vector, Predicate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gae71449b1cc6e6250b91f539153a7a0d3"><td class="memItemLeft" align="right" valign="top"><a id="gae71449b1cc6e6250b91f539153a7a0d3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gae71449b1cc6e6250b91f539153a7a0d3">M_PI</a>&#160;&#160;&#160;3.1415926535897932384626433832795028841971693993751</td></tr>
<tr class="memdesc:gae71449b1cc6e6250b91f539153a7a0d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <img class="formulaInl" alt="$\pi$" src="../../form_23.png"/> constant, if not defined elsewhere. <br /></td></tr>
<tr class="separator:gae71449b1cc6e6250b91f539153a7a0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gae31ab711c340f212485ef175337dbe40"><td class="memItemLeft" align="right" valign="top"><a id="gae31ab711c340f212485ef175337dbe40"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>sccindex_t</b></td></tr>
<tr class="separator:gae31ab711c340f212485ef175337dbe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31c1b5dd90314db1962f5e493087c022"><td class="memItemLeft" align="right" valign="top"><a id="ga31c1b5dd90314db1962f5e493087c022"></a>
typedef struct <a class="el" href="../../d9/d61/structscc__node.html">scc_node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>scc_node</b></td></tr>
<tr class="separator:ga31c1b5dd90314db1962f5e493087c022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8873f9426ad117dde846971345079b8e"><td class="memItemLeft" align="right" valign="top"><a id="ga8873f9426ad117dde846971345079b8e"></a>
typedef struct <a class="el" href="../../dc/d36/structdfs__visit__node.html">dfs_visit_node</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dfs_visit_node</b></td></tr>
<tr class="separator:ga8873f9426ad117dde846971345079b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a059fdb173202a12d904121fe8aa709"><td class="memItemLeft" align="right" valign="top"><a id="ga3a059fdb173202a12d904121fe8aa709"></a>
typedef struct <a class="el" href="../../d0/da5/structFoxGlynnWeights.html">FoxGlynnWeights</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FoxGlynnWeights</b></td></tr>
<tr class="separator:ga3a059fdb173202a12d904121fe8aa709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f95cfa095fbe22b36c13992ae80a92a"><td class="memItemLeft" align="right" valign="top"><a id="ga1f95cfa095fbe22b36c13992ae80a92a"></a>
typedef struct <a class="el" href="../../d0/de5/structNullPreconditioner.html">NullPreconditioner</a>&#160;</td><td class="memItemRight" valign="bottom"><b>NullPreconditioner</b></td></tr>
<tr class="separator:ga1f95cfa095fbe22b36c13992ae80a92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac6a1527442025e3ba2e3569022d3476"><td class="memItemLeft" align="right" valign="top"><a id="gaac6a1527442025e3ba2e3569022d3476"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>subsetindex_t</b></td></tr>
<tr class="separator:gaac6a1527442025e3ba2e3569022d3476"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga574905831111f39e07c8d1b9b53d1044"><td class="memItemLeft" align="right" valign="top"><a id="ga574905831111f39e07c8d1b9b53d1044"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>DfsVisitState</b> { <b>DFS_ENTER</b>, 
<b>DFS_CONTINUE</b>
 }</td></tr>
<tr class="separator:ga574905831111f39e07c8d1b9b53d1044"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gad9c1b98b90c469d9a2ed08e8c9df5041"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:gad9c1b98b90c469d9a2ed08e8c9df5041"><td class="memTemplItemLeft" align="right" valign="top">sccindex_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gad9c1b98b90c469d9a2ed08e8c9df5041">TarjanIterative</a> (const Matrix &amp;mat, std::vector&lt; sccindex_t &gt; &amp;SCC)</td></tr>
<tr class="separator:gad9c1b98b90c469d9a2ed08e8c9df5041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6bf5ffc484217fab980476848108979"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:gac6bf5ffc484217fab980476848108979"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gac6bf5ffc484217fab980476848108979">BottomStronglyConnectedComponents</a> (const Matrix &amp;mat, <a class="el" href="../../de/dc9/classBSCC.html">BSCC</a> &amp;bscc)</td></tr>
<tr class="separator:gac6bf5ffc484217fab980476848108979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga478771c447c007fb2078c9c7b46429c9"><td class="memItemLeft" align="right" valign="top"><a id="ga478771c447c007fb2078c9c7b46429c9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_machine_epsilon</b> (float &amp;v)</td></tr>
<tr class="separator:ga478771c447c007fb2078c9c7b46429c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93986079e0ee84d781c8e4a2497192db"><td class="memItemLeft" align="right" valign="top"><a id="ga93986079e0ee84d781c8e4a2497192db"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_machine_epsilon</b> (double &amp;v)</td></tr>
<tr class="separator:ga93986079e0ee84d781c8e4a2497192db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5348f423dfaf969dc4042ae5ba41a5ae"><td class="memItemLeft" align="right" valign="top"><a id="ga5348f423dfaf969dc4042ae5ba41a5ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>get_machine_epsilon</b> (long double &amp;v)</td></tr>
<tr class="separator:ga5348f423dfaf969dc4042ae5ba41a5ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9618cdcd0e997367b9107489e22ef9c"><td class="memTemplParams" colspan="2"><a id="gae9618cdcd0e997367b9107489e22ef9c"></a>
template&lt;class Real &gt; </td></tr>
<tr class="memitem:gae9618cdcd0e997367b9107489e22ef9c"><td class="memTemplItemLeft" align="right" valign="top">Real&#160;</td><td class="memTemplItemRight" valign="bottom"><b>less_than_machine_epsilon</b> (Real v)</td></tr>
<tr class="separator:gae9618cdcd0e997367b9107489e22ef9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadba04bac7eca9d49f6147a666a29bbec"><td class="memTemplParams" colspan="2"><a id="gadba04bac7eca9d49f6147a666a29bbec"></a>
template&lt;class Real &gt; </td></tr>
<tr class="memitem:gadba04bac7eca9d49f6147a666a29bbec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GeneratePlaneRotation</b> (const Real dx, const Real dy, Real &amp;cs, Real &amp;sn)</td></tr>
<tr class="separator:gadba04bac7eca9d49f6147a666a29bbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea56107829c3149ecc861af6e6831970"><td class="memTemplParams" colspan="2"><a id="gaea56107829c3149ecc861af6e6831970"></a>
template&lt;class Real &gt; </td></tr>
<tr class="memitem:gaea56107829c3149ecc861af6e6831970"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ApplyPlaneRotation</b> (Real &amp;dx, Real &amp;dy, const Real cs, const Real sn)</td></tr>
<tr class="separator:gaea56107829c3149ecc861af6e6831970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c920b09e9f8312469b87122ef1a3d55"><td class="memTemplParams" colspan="2"><a id="ga9c920b09e9f8312469b87122ef1a3d55"></a>
template&lt;class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:ga9c920b09e9f8312469b87122ef1a3d55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Update</b> (Vector &amp;x, int k, const Matrix &amp;h, const Vector &amp;s, const std::vector&lt; Vector &gt; &amp;v, const std::vector&lt; Vector &gt; &amp;z, const <a class="el" href="../../d0/d05/structPreconditioner.html">Preconditioner</a> &amp;R, bool is_fgmres)</td></tr>
<tr class="separator:ga9c920b09e9f8312469b87122ef1a3d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4ffdd6a0a4e5caf34fa2c4585d2c159"><td class="memTemplParams" colspan="2"><a id="gae4ffdd6a0a4e5caf34fa2c4585d2c159"></a>
template&lt;class ResidualFunctor , class Vector , class VectorB , class Matrix , class Real &gt; </td></tr>
<tr class="memitem:gae4ffdd6a0a4e5caf34fa2c4585d2c159"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GMRES</b> (const ResidualFunctor &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, Vector &amp;x, const VectorB &amp;b, const <a class="el" href="../../d0/d05/structPreconditioner.html">Preconditioner</a> &amp;L, const <a class="el" href="../../d0/d05/structPreconditioner.html">Preconditioner</a> &amp;R, Matrix &amp;H, size_t &amp;m, bool is_fgmres, size_t &amp;max_iter, Real &amp;tol, <a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;printOut)</td></tr>
<tr class="separator:gae4ffdd6a0a4e5caf34fa2c4585d2c159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a6d544cb7af9a794956d237e43e2b0d"><td class="memTemplParams" colspan="2"><a id="ga0a6d544cb7af9a794956d237e43e2b0d"></a>
template&lt;class ResidualFunctor , class Vector , class VectorB , class Real &gt; </td></tr>
<tr class="memitem:ga0a6d544cb7af9a794956d237e43e2b0d"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>BiCGSTAB</b> (const ResidualFunctor &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, Vector &amp;x, const VectorB &amp;b, const <a class="el" href="../../d0/d05/structPreconditioner.html">Preconditioner</a> &amp;M, size_t &amp;max_iter, Real &amp;tol, <a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;printOut)</td></tr>
<tr class="separator:ga0a6d544cb7af9a794956d237e43e2b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga387d041c730de700fb366e797b858f67"><td class="memTemplParams" colspan="2"><a id="ga387d041c730de700fb366e797b858f67"></a>
template&lt;class ResidualFunctor , class Vector , class VectorB , class Real &gt; </td></tr>
<tr class="memitem:ga387d041c730de700fb366e797b858f67"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>CGS</b> (const ResidualFunctor &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, Vector &amp;x, const VectorB &amp;b, const <a class="el" href="../../d0/d05/structPreconditioner.html">Preconditioner</a> &amp;M, size_t &amp;max_iter, Real &amp;tol, <a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;printOut)</td></tr>
<tr class="separator:ga387d041c730de700fb366e797b858f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb8018704ecc0b0443eb0e7c3e617a7"><td class="memTemplParams" colspan="2"><a id="ga0eb8018704ecc0b0443eb0e7c3e617a7"></a>
template&lt;class ResidualFunctor , class Vector , class VectorB , class Real &gt; </td></tr>
<tr class="memitem:ga0eb8018704ecc0b0443eb0e7c3e617a7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><b>IR</b> (const ResidualFunctor &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, Vector &amp;x, const VectorB &amp;b, const <a class="el" href="../../d0/d05/structPreconditioner.html">Preconditioner</a> &amp;M, size_t &amp;max_iter, Real &amp;tol, Real omega, <a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;printOut)</td></tr>
<tr class="separator:ga0eb8018704ecc0b0443eb0e7c3e617a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2068d37383331c748e6f83eb852d1d9a"><td class="memTemplParams" colspan="2"><a id="ga2068d37383331c748e6f83eb852d1d9a"></a>
template&lt;class Matrix , class VectorIn , class VectorB , class VectorD , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:ga2068d37383331c748e6f83eb852d1d9a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>KrylovSolve</b> (VectorIn &amp;x_, const Matrix &amp;A_, const VectorB &amp;b_, const VectorD &amp;d_, KolmogorovEquationDirection ked, const <a class="el" href="../../d9/d03/structSolverParams.html">SolverParams</a> &amp;spar, <a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;printOut, const RowSelector &amp;rows, const ColSelector &amp;cols, const VectorIn *init_x0_=nullptr)</td></tr>
<tr class="separator:ga2068d37383331c748e6f83eb852d1d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga028ac6c84c1380e8b495c5463d18745c"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorS , class VectorD , class VectorPi , class VectorRho &gt; </td></tr>
<tr class="memitem:ga028ac6c84c1380e8b495c5463d18745c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga028ac6c84c1380e8b495c5463d18745c">Solve_SteadyState_ErgodicMC</a> (const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, VectorS &amp;sol, const VectorD &amp;d, const VectorPi &amp;pi0, const VectorRho &amp;rho, KolmogorovEquationDirection ked, const <a class="el" href="../../d9/d03/structSolverParams.html">SolverParams</a> &amp;spar, <a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;printOut, const char *mcClass, const VectorS *init_x0=nullptr)</td></tr>
<tr class="separator:ga028ac6c84c1380e8b495c5463d18745c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2bd253d95cc443d2e270937af60fb2a"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorS , class VectorPi , class VectorRho , class VectorD &gt; </td></tr>
<tr class="memitem:gab2bd253d95cc443d2e270937af60fb2a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gab2bd253d95cc443d2e270937af60fb2a">Solve_SteadyState_MC</a> (const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, VectorS &amp;sol, const VectorD &amp;d, const VectorPi &amp;pi0, const VectorRho &amp;rho, KolmogorovEquationDirection ked, const <a class="el" href="../../d9/d03/structSolverParams.html">SolverParams</a> &amp;spar, const <a class="el" href="../../de/dc9/classBSCC.html">BSCC</a> &amp;bscc, <a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;printOut, const char *mcClass, const VectorS *init_x0=nullptr)</td></tr>
<tr class="separator:gab2bd253d95cc443d2e270937af60fb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c07ffe237fbd12e000434b4fff1cd71"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:ga3c07ffe237fbd12e000434b4fff1cd71"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga3c07ffe237fbd12e000434b4fff1cd71">Solve_SteadyState_ErgodicCTMC</a> (const Matrix &amp;Q, Vector &amp;sol, KolmogorovEquationDirection ked, const <a class="el" href="../../d9/d03/structSolverParams.html">SolverParams</a> &amp;spar, <a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;printOut, const Vector *init_x0=nullptr)</td></tr>
<tr class="separator:ga3c07ffe237fbd12e000434b4fff1cd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1bde3a28182d066e175ac16286d6b84"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class Vector1 , class Vector2 , class Vector3 &gt; </td></tr>
<tr class="memitem:gae1bde3a28182d066e175ac16286d6b84"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gae1bde3a28182d066e175ac16286d6b84">Solve_SteadyState_CTMC</a> (const Matrix &amp;Q, Vector1 &amp;sol, const Vector2 &amp;pi0, const Vector3 &amp;rho, KolmogorovEquationDirection ked, const <a class="el" href="../../d9/d03/structSolverParams.html">SolverParams</a> &amp;spar, const <a class="el" href="../../de/dc9/classBSCC.html">BSCC</a> &amp;bscc, <a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;printOut, const Vector1 *init_x0=nullptr)</td></tr>
<tr class="separator:gae1bde3a28182d066e175ac16286d6b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d2a1228628f7106eb7fb7f24fb3abc3"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class Vector &gt; </td></tr>
<tr class="memitem:ga1d2a1228628f7106eb7fb7f24fb3abc3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga1d2a1228628f7106eb7fb7f24fb3abc3">Solve_SteadyState_ErgodicDTMC</a> (const Matrix &amp;P, Vector &amp;sol, KolmogorovEquationDirection ked, const <a class="el" href="../../d9/d03/structSolverParams.html">SolverParams</a> &amp;spar, <a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;printOut, const Vector *init_x0=nullptr)</td></tr>
<tr class="separator:ga1d2a1228628f7106eb7fb7f24fb3abc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga585741407f370039e6a097d700cec97d"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class Vector1 , class Vector2 , class Vector3 &gt; </td></tr>
<tr class="memitem:ga585741407f370039e6a097d700cec97d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga585741407f370039e6a097d700cec97d">Solve_SteadyState_DTMC</a> (const Matrix &amp;P, Vector1 &amp;sol, const Vector2 &amp;pi0, const Vector3 &amp;rho, KolmogorovEquationDirection ked, const <a class="el" href="../../d9/d03/structSolverParams.html">SolverParams</a> &amp;spar, const <a class="el" href="../../de/dc9/classBSCC.html">BSCC</a> &amp;bscc, <a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;printOut, const Vector1 *init_x0=nullptr)</td></tr>
<tr class="separator:ga585741407f370039e6a097d700cec97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75338d4b8b76a958b2d19196f84e2836"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorX , class VectorOut , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:ga75338d4b8b76a958b2d19196f84e2836"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga75338d4b8b76a958b2d19196f84e2836">add_prod_vecmat</a> (VectorOut &amp;y, const VectorX &amp;x, const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:ga75338d4b8b76a958b2d19196f84e2836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3e91ea9c1bd63130545bdfdc99f6946"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorX , class VectorOut , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:gac3e91ea9c1bd63130545bdfdc99f6946"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gac3e91ea9c1bd63130545bdfdc99f6946">prod_vecmat</a> (VectorOut &amp;y, const VectorX &amp;x, const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:gac3e91ea9c1bd63130545bdfdc99f6946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c091d71c07cdba65e14427039511de4"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorX , class VectorOut , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:ga2c091d71c07cdba65e14427039511de4"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga2c091d71c07cdba65e14427039511de4">add_prod_matvec</a> (VectorOut &amp;y, const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, const VectorX &amp;x, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:ga2c091d71c07cdba65e14427039511de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21687d83fa40e07c1b336380c2177c4f"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorX , class VectorOut , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:ga21687d83fa40e07c1b336380c2177c4f"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga21687d83fa40e07c1b336380c2177c4f">prod_matvec</a> (VectorOut &amp;y, const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, const VectorX &amp;x, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:ga21687d83fa40e07c1b336380c2177c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf94b68aee8a871e6977495d212985b23"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorX , class VectorD , class VectorOut , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:gaf94b68aee8a871e6977495d212985b23"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gaf94b68aee8a871e6977495d212985b23">prod_matvec_diag</a> (VectorOut &amp;y, const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, const VectorD &amp;d, const VectorX &amp;x, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:gaf94b68aee8a871e6977495d212985b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ced41adea05195b679fcb600b6edf35"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorX , class VectorD , class VectorOut , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:ga6ced41adea05195b679fcb600b6edf35"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga6ced41adea05195b679fcb600b6edf35">prod_vecmat_diag</a> (VectorOut &amp;y, const VectorX &amp;x, const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, const VectorD &amp;d, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:ga6ced41adea05195b679fcb600b6edf35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga656ef9246f1217485db9ec682153a352"><td class="memTemplParams" colspan="2">template&lt;class VectorOut , class VectorIn , class Selector &gt; </td></tr>
<tr class="memitem:ga656ef9246f1217485db9ec682153a352"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga656ef9246f1217485db9ec682153a352">plus_assign_mult</a> (VectorOut &amp;y, const double c, const VectorIn &amp;x, const Selector &amp;rows)</td></tr>
<tr class="separator:ga656ef9246f1217485db9ec682153a352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga366b93973649e254cce28c63f703e2e1"><td class="memTemplParams" colspan="2">template&lt;class VectorOut , class VectorIn , class Selector &gt; </td></tr>
<tr class="memitem:ga366b93973649e254cce28c63f703e2e1"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga366b93973649e254cce28c63f703e2e1">assign_mult</a> (VectorOut &amp;y, const double c, const VectorIn &amp;x, const Selector &amp;rows)</td></tr>
<tr class="separator:ga366b93973649e254cce28c63f703e2e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbad51835d91dfebb7cf1fdd0b2bf4e3"><td class="memTemplParams" colspan="2">template&lt;class VectorIn , class VectorOut , class Selector &gt; </td></tr>
<tr class="memitem:gadbad51835d91dfebb7cf1fdd0b2bf4e3"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gadbad51835d91dfebb7cf1fdd0b2bf4e3">copy_vec</a> (VectorOut &amp;y, const VectorIn &amp;x, const Selector &amp;rows)</td></tr>
<tr class="separator:gadbad51835d91dfebb7cf1fdd0b2bf4e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13fac47d7d0ae93958c42c3da75ecfd8"><td class="memTemplParams" colspan="2">template&lt;class VectorIn , class VectorOut , class Selector &gt; </td></tr>
<tr class="memitem:ga13fac47d7d0ae93958c42c3da75ecfd8"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga13fac47d7d0ae93958c42c3da75ecfd8">add_vec</a> (VectorOut &amp;y, const VectorIn &amp;x, const Selector &amp;rows)</td></tr>
<tr class="separator:ga13fac47d7d0ae93958c42c3da75ecfd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c3bb1edfd13e82686e9ea9d3491e45b"><td class="memTemplParams" colspan="2">template&lt;class VectorOut , class Selector &gt; </td></tr>
<tr class="memitem:ga9c3bb1edfd13e82686e9ea9d3491e45b"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga9c3bb1edfd13e82686e9ea9d3491e45b">mult_vec</a> (VectorOut &amp;y, const double factor, const Selector &amp;rows)</td></tr>
<tr class="separator:ga9c3bb1edfd13e82686e9ea9d3491e45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ee0feca6dda953b6290bc7cb82846a1"><td class="memTemplParams" colspan="2">template&lt;class VectorOut , class Selector &gt; </td></tr>
<tr class="memitem:ga2ee0feca6dda953b6290bc7cb82846a1"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga2ee0feca6dda953b6290bc7cb82846a1">div_vec</a> (VectorOut &amp;y, const double factor, const Selector &amp;rows)</td></tr>
<tr class="separator:ga2ee0feca6dda953b6290bc7cb82846a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga179f3f76a0e789ceaa76bab6c5a7ab32"><td class="memTemplParams" colspan="2">template&lt;class VectorOut , class Selector &gt; </td></tr>
<tr class="memitem:ga179f3f76a0e789ceaa76bab6c5a7ab32"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga179f3f76a0e789ceaa76bab6c5a7ab32">add_vec</a> (VectorOut &amp;y, const double factor, const Selector &amp;rows)</td></tr>
<tr class="separator:ga179f3f76a0e789ceaa76bab6c5a7ab32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacbc8b1c21be576ebdabbe1bd087b19f"><td class="memTemplParams" colspan="2">template&lt;class VectorOut , class Selector &gt; </td></tr>
<tr class="memitem:gaacbc8b1c21be576ebdabbe1bd087b19f"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gaacbc8b1c21be576ebdabbe1bd087b19f">set_vec</a> (VectorOut &amp;y, const double factor, const Selector &amp;rows)</td></tr>
<tr class="separator:gaacbc8b1c21be576ebdabbe1bd087b19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4dddab73b549fbd5da05074a25a6627"><td class="memTemplParams" colspan="2">template&lt;class VectorOut &gt; </td></tr>
<tr class="memitem:gaf4dddab73b549fbd5da05074a25a6627"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gaf4dddab73b549fbd5da05074a25a6627">set_vec</a> (VectorOut &amp;y, const double factor)</td></tr>
<tr class="separator:gaf4dddab73b549fbd5da05074a25a6627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35f155ed1007f2039c2a2e4df4dd26fe"><td class="memTemplParams" colspan="2">template&lt;class VectorIn , class Selector &gt; </td></tr>
<tr class="memitem:ga35f155ed1007f2039c2a2e4df4dd26fe"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga35f155ed1007f2039c2a2e4df4dd26fe">norm_1</a> (VectorIn &amp;x, const Selector &amp;rows)</td></tr>
<tr class="separator:ga35f155ed1007f2039c2a2e4df4dd26fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga996678eec1bac1e1085dbe62da0cef6e"><td class="memTemplParams" colspan="2">template&lt;class VectorIn , class Selector &gt; </td></tr>
<tr class="memitem:ga996678eec1bac1e1085dbe62da0cef6e"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga996678eec1bac1e1085dbe62da0cef6e">vec_sum</a> (const VectorIn &amp;x, const Selector &amp;rows)</td></tr>
<tr class="separator:ga996678eec1bac1e1085dbe62da0cef6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5878272da12d76146e9736f772ff2f0b"><td class="memTemplParams" colspan="2">template&lt;class VectorIn &gt; </td></tr>
<tr class="memitem:ga5878272da12d76146e9736f772ff2f0b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga5878272da12d76146e9736f772ff2f0b">vec_sum</a> (const VectorIn &amp;x)</td></tr>
<tr class="separator:ga5878272da12d76146e9736f772ff2f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c89d171bb83ffd0987b4b7599c0468a"><td class="memTemplParams" colspan="2">template&lt;class VectorIn1 , class VectorIn2 , class Selector &gt; </td></tr>
<tr class="memitem:ga4c89d171bb83ffd0987b4b7599c0468a"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga4c89d171bb83ffd0987b4b7599c0468a">vec_dot</a> (const VectorIn1 &amp;x, const VectorIn2 &amp;y, const Selector &amp;rows)</td></tr>
<tr class="separator:ga4c89d171bb83ffd0987b4b7599c0468a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9fd8cec43d936a584a6dba09b359559"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorX , class VectorOut , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:gab9fd8cec43d936a584a6dba09b359559"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gab9fd8cec43d936a584a6dba09b359559">prod_vecmat_unif</a> (VectorOut &amp;y, const VectorX &amp;x, const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, const double lambda, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:gab9fd8cec43d936a584a6dba09b359559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55ff6bca7609185e286b8eb4687f701a"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorX , class VectorOut , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:ga55ff6bca7609185e286b8eb4687f701a"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga55ff6bca7609185e286b8eb4687f701a">prod_matvec_unif</a> (VectorOut &amp;y, const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, const VectorX &amp;x, const double lambda, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:ga55ff6bca7609185e286b8eb4687f701a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga96e76ef047bc21e64dbd5780921179e3"><td class="memTemplParams" colspan="2">template&lt;class VectorIn , class VectorOut , class Matrix , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:ga96e76ef047bc21e64dbd5780921179e3"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga96e76ef047bc21e64dbd5780921179e3">prod_vec_invDiagM_M</a> (VectorOut &amp;outVec, const VectorIn &amp;inVec, const Matrix &amp;M, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:ga96e76ef047bc21e64dbd5780921179e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d4ac3e67017bd2a4dcbaf9c6fde802a"><td class="memTemplParams" colspan="2">template&lt;class VectorIn , class VectorOut , class Matrix , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:ga6d4ac3e67017bd2a4dcbaf9c6fde802a"><td class="memTemplItemLeft" align="right" valign="top">VectorOut &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga6d4ac3e67017bd2a4dcbaf9c6fde802a">prod_invDiagM_M_vec</a> (VectorOut &amp;outVec, const Matrix &amp;M, const VectorIn &amp;inVec, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:ga6d4ac3e67017bd2a4dcbaf9c6fde802a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga245530c619f15f689303b0dfb6827a11"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:ga245530c619f15f689303b0dfb6827a11"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga245530c619f15f689303b0dfb6827a11">filter_matrix</a> (const Matrix &amp;inM, Matrix &amp;outM, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:ga245530c619f15f689303b0dfb6827a11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa761f5eb727fe6df3cb364b8172240c5"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:gaa761f5eb727fe6df3cb364b8172240c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gaa761f5eb727fe6df3cb364b8172240c5">project_matrix</a> (const Matrix &amp;inM, Matrix &amp;outM, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:gaa761f5eb727fe6df3cb364b8172240c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a2de70f0fcdfb3b41f9a5d4a77d6bf4"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class RowSelector , class ColSelector , class InvColSelector &gt; </td></tr>
<tr class="memitem:ga3a2de70f0fcdfb3b41f9a5d4a77d6bf4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga3a2de70f0fcdfb3b41f9a5d4a77d6bf4">project_matrix_inv</a> (const Matrix &amp;inM, Matrix &amp;outM, const RowSelector &amp;rows, const ColSelector &amp;cols, const InvColSelector &amp;colsInv)</td></tr>
<tr class="separator:ga3a2de70f0fcdfb3b41f9a5d4a77d6bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga303361b96abf70839bc89feafd46df6a"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:ga303361b96abf70839bc89feafd46df6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga303361b96abf70839bc89feafd46df6a">unproject_matrix</a> (const Matrix &amp;inM, Matrix &amp;outM, size_t NR, size_t NC, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:ga303361b96abf70839bc89feafd46df6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02656b2faaea43c0618182cdb114fb2b"><td class="memTemplParams" colspan="2">template&lt;class VectorIn , class VectorOut , class Selector &gt; </td></tr>
<tr class="memitem:ga02656b2faaea43c0618182cdb114fb2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga02656b2faaea43c0618182cdb114fb2b">project_vector</a> (const VectorIn &amp;inV, VectorOut &amp;outV, const Selector &amp;sel)</td></tr>
<tr class="separator:ga02656b2faaea43c0618182cdb114fb2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42afab68c14d7855367c02966b6a92c8"><td class="memTemplParams" colspan="2">template&lt;class VectorIn , class VectorOut , class Selector &gt; </td></tr>
<tr class="memitem:ga42afab68c14d7855367c02966b6a92c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga42afab68c14d7855367c02966b6a92c8">unproject_vector</a> (const VectorIn &amp;inV, VectorOut &amp;outV, size_t N, const Selector &amp;sel)</td></tr>
<tr class="separator:ga42afab68c14d7855367c02966b6a92c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ee6c552b6a423ee79a51edfce5e65b6"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:ga3ee6c552b6a423ee79a51edfce5e65b6"><td class="memTemplItemLeft" align="right" valign="top">Matrix::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga3ee6c552b6a423ee79a51edfce5e65b6">NormInf</a> (const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>)</td></tr>
<tr class="separator:ga3ee6c552b6a423ee79a51edfce5e65b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2769e0ee80cb0d7ae3d23234da44604d"><td class="memTemplParams" colspan="2">template&lt;class E &gt; </td></tr>
<tr class="memitem:ga2769e0ee80cb0d7ae3d23234da44604d"><td class="memTemplItemLeft" align="right" valign="top">ublas::matrix&lt; typename E::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga2769e0ee80cb0d7ae3d23234da44604d">Inverse</a> (const ublas::matrix_expression&lt; E &gt; &amp;input)</td></tr>
<tr class="separator:ga2769e0ee80cb0d7ae3d23234da44604d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfe0679dc6369402ee3104739ee72537"><td class="memItemLeft" align="right" valign="top"><a id="gacfe0679dc6369402ee3104739ee72537"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>safe_inv</b> (double v)</td></tr>
<tr class="separator:gacfe0679dc6369402ee3104739ee72537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2eac7de08404d3176345de87d6ab2bf2"><td class="memTemplParams" colspan="2">template&lt;class MatA , class MatD , class VecB , class VecX &gt; </td></tr>
<tr class="memitem:ga2eac7de08404d3176345de87d6ab2bf2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga2eac7de08404d3176345de87d6ab2bf2">BackSubstitution</a> (const MatA &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, const MatD &amp;Diag, const VecB &amp;b, VecX &amp;x)</td></tr>
<tr class="separator:ga2eac7de08404d3176345de87d6ab2bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49bb2709656c53668edfa281d129f51a"><td class="memTemplParams" colspan="2">template&lt;class MatA , class MatD , class VecB , class VecX &gt; </td></tr>
<tr class="memitem:ga49bb2709656c53668edfa281d129f51a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga49bb2709656c53668edfa281d129f51a">ForeSubstitution</a> (const MatA &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, const MatD &amp;Diag, const VecB &amp;b, VecX &amp;x)</td></tr>
<tr class="memdesc:ga49bb2709656c53668edfa281d129f51a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a fore-substitution with the Lower Triangular <a class="el" href="../../d2/d88/classA.html">A</a> matrix.  <a href="#ga49bb2709656c53668edfa281d129f51a">More...</a><br /></td></tr>
<tr class="separator:ga49bb2709656c53668edfa281d129f51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3203ef58d792aefffa23cfe4b3c92002"><td class="memTemplParams" colspan="2">template&lt;class ostream_t , class Matrix &gt; </td></tr>
<tr class="memitem:ga3203ef58d792aefffa23cfe4b3c92002"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga3203ef58d792aefffa23cfe4b3c92002">print_matrix</a> (ostream_t &amp;os, const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, const char *name)</td></tr>
<tr class="memdesc:ga3203ef58d792aefffa23cfe4b3c92002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print out a matrix onto the specified stream.  <a href="#ga3203ef58d792aefffa23cfe4b3c92002">More...</a><br /></td></tr>
<tr class="separator:ga3203ef58d792aefffa23cfe4b3c92002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae49027fe4cfaab6360fc9008112a4e7f"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gae49027fe4cfaab6360fc9008112a4e7f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gae49027fe4cfaab6360fc9008112a4e7f">compress_matrix</a> (ublas::compressed_matrix&lt; T &gt; &amp;dst, const <a class="el" href="../../d4/db1/classmatrix__map.html">matrix_map</a>&lt; T &gt; &amp;src)</td></tr>
<tr class="memdesc:gae49027fe4cfaab6360fc9008112a4e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compress a <a class="el" href="../../d4/db1/classmatrix__map.html" title="Intermediate class that implements a matrix-like interface for filling a matrix in sparse order...">matrix_map</a> instance into a ublas::compressed_matrix.  <a href="#gae49027fe4cfaab6360fc9008112a4e7f">More...</a><br /></td></tr>
<tr class="separator:gae49027fe4cfaab6360fc9008112a4e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa47302b338072cff21819c2e8c5c6d74"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gaa47302b338072cff21819c2e8c5c6d74"><td class="memTemplItemLeft" align="right" valign="top">ublas::compressed_matrix&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gaa47302b338072cff21819c2e8c5c6d74">FastTranspose</a> (const ublas::compressed_matrix&lt; T &gt; &amp;in, ublas::compressed_matrix&lt; T &gt; &amp;out)</td></tr>
<tr class="memdesc:gaa47302b338072cff21819c2e8c5c6d74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast transposition of a sparse matrix.  <a href="#gaa47302b338072cff21819c2e8c5c6d74">More...</a><br /></td></tr>
<tr class="separator:gaa47302b338072cff21819c2e8c5c6d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace17e98e229747a7940e082eec16ee83"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:gace17e98e229747a7940e082eec16ee83"><td class="memTemplItemLeft" align="right" valign="top">ublas::matrix&lt; T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gace17e98e229747a7940e082eec16ee83">FastTranspose</a> (const ublas::matrix&lt; T &gt; &amp;in, ublas::matrix&lt; T &gt; &amp;out)</td></tr>
<tr class="memdesc:gace17e98e229747a7940e082eec16ee83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast transposition of a sparse matrix.  <a href="#gace17e98e229747a7940e082eec16ee83">More...</a><br /></td></tr>
<tr class="separator:gace17e98e229747a7940e082eec16ee83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4370325ccac4572c34024e8cfeffab6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gae4370325ccac4572c34024e8cfeffab6">FG_Finder</a> (const double lambda, const double epsilon, const double tau, const double omega, <a class="el" href="../../d0/da5/structFoxGlynnWeights.html">FoxGlynnWeights</a> &amp;fgw, double &amp;W_M, <a class="el" href="../../d9/ddb/group__Numeric.html#ga0822d01c051e2b76c48c9ae19b07a471">VerboseLevel</a> verboseLvl)</td></tr>
<tr class="separator:gae4370325ccac4572c34024e8cfeffab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga232ce6a75582ea44e06ce13eb26fc513"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga232ce6a75582ea44e06ce13eb26fc513">FG_Weighter</a> (const double lambda, const double epsilon, const double tau, const double omega, <a class="el" href="../../d0/da5/structFoxGlynnWeights.html">FoxGlynnWeights</a> &amp;fgw, <a class="el" href="../../d9/ddb/group__Numeric.html#ga0822d01c051e2b76c48c9ae19b07a471">VerboseLevel</a> verboseLvl)</td></tr>
<tr class="separator:ga232ce6a75582ea44e06ce13eb26fc513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab702b27c6cc6a5252e14919b984a4770"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:gab702b27c6cc6a5252e14919b984a4770"><td class="memTemplItemLeft" align="right" valign="top">Matrix::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gab702b27c6cc6a5252e14919b984a4770">ILU0</a> (Matrix &amp;M, <a class="el" href="../../d9/ddb/group__Numeric.html#ga0822d01c051e2b76c48c9ae19b07a471">VerboseLevel</a> verboseLvl)</td></tr>
<tr class="separator:gab702b27c6cc6a5252e14919b984a4770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f142fe5a7e709d2f6f54d0b8a149820"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:ga2f142fe5a7e709d2f6f54d0b8a149820"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga2f142fe5a7e709d2f6f54d0b8a149820">ILUTK</a> (const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, ublas::compressed_matrix&lt; typename Matrix::value_type &gt; &amp;outP, typename Matrix::value_type threshold, size_t K, <a class="el" href="../../d9/ddb/group__Numeric.html#ga0822d01c051e2b76c48c9ae19b07a471">VerboseLevel</a> verboseLvl)</td></tr>
<tr class="separator:ga2f142fe5a7e709d2f6f54d0b8a149820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga370c44e673aa8f028fba38d396a5b6c1"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorIn , class VectorB , class VectorD , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:ga370c44e673aa8f028fba38d396a5b6c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga370c44e673aa8f028fba38d396a5b6c1">JacobiIteration</a> (const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, VectorIn &amp;x, const VectorB &amp;b, const VectorD &amp;d, const double omega, VectorIn &amp;x_next, double &amp;max_err, double &amp;x_norm, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:ga370c44e673aa8f028fba38d396a5b6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab536f03ce513723b5abcd7fc173f8cf4"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorIn , class VectorB , class VectorD , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:gab536f03ce513723b5abcd7fc173f8cf4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gab536f03ce513723b5abcd7fc173f8cf4">ForwardGaussSeidelIteration</a> (const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, VectorIn &amp;x, const VectorB &amp;b, const VectorD &amp;d, const double omega, double &amp;max_err, double &amp;x_norm, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:gab536f03ce513723b5abcd7fc173f8cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31d7722a852d33dbe4f14484a3f11ea9"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorIn , class VectorB , class VectorD , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:ga31d7722a852d33dbe4f14484a3f11ea9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga31d7722a852d33dbe4f14484a3f11ea9">BackwardGaussSeidelIteration</a> (const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, VectorIn &amp;x, const VectorB &amp;b, const VectorD &amp;d, const double omega, double &amp;max_err, double &amp;x_norm, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:ga31d7722a852d33dbe4f14484a3f11ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga542b7d72281839d39d2439ae3ca3ab91"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorIn , class VectorB , class VectorD , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:ga542b7d72281839d39d2439ae3ca3ab91"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga542b7d72281839d39d2439ae3ca3ab91">JacobiTransIteration</a> (VectorIn &amp;x, const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, const VectorB &amp;b, const VectorD &amp;d, const double omega, VectorIn &amp;sigma, double &amp;max_err, double &amp;x_norm, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:ga542b7d72281839d39d2439ae3ca3ab91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacdc970def63d8b46e1ef5a1cc996b10c"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorIn , class VectorB , class VectorD , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:gacdc970def63d8b46e1ef5a1cc996b10c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gacdc970def63d8b46e1ef5a1cc996b10c">ForwardGaussSeidelTransIteration</a> (VectorIn &amp;x, const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, const VectorB &amp;b, const VectorD &amp;d, const double omega, VectorIn &amp;xLU, vector&lt; size_t &gt; startOfU, double &amp;max_err, double &amp;x_norm, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:gacdc970def63d8b46e1ef5a1cc996b10c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad49e50bc2a7b246912e9853d2ee1fec9"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorIn , class VectorB , class VectorD , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:gad49e50bc2a7b246912e9853d2ee1fec9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gad49e50bc2a7b246912e9853d2ee1fec9">BackwardGaussSeidelTransIteration</a> (VectorIn &amp;x, const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, const VectorB &amp;b, const VectorD &amp;d, const double omega, VectorIn &amp;xLU, vector&lt; size_t &gt; startOfU, double &amp;max_err, double &amp;x_norm, const RowSelector &amp;rows, const ColSelector &amp;cols)</td></tr>
<tr class="separator:gad49e50bc2a7b246912e9853d2ee1fec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87db4bad71c1ae512bcf0c24bb15170f"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorIn , class VectorB , class VectorD , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:ga87db4bad71c1ae512bcf0c24bb15170f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga87db4bad71c1ae512bcf0c24bb15170f">LinearSolve</a> (VectorIn &amp;x, const Matrix &amp;<a class="el" href="../../d2/d88/classA.html">A</a>, const VectorB &amp;b, const VectorD &amp;d, KolmogorovEquationDirection ked, const <a class="el" href="../../d9/d03/structSolverParams.html">SolverParams</a> &amp;spar, <a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;printOut, const RowSelector &amp;rows, const ColSelector &amp;cols, const VectorIn *init_x0=nullptr)</td></tr>
<tr class="separator:ga87db4bad71c1ae512bcf0c24bb15170f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7412c545617e7b9559a780bcd3853ead"><td class="memTemplParams" colspan="2">template&lt;class Matrix , class VectorIn , class VectorOut , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:ga7412c545617e7b9559a780bcd3853ead"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga7412c545617e7b9559a780bcd3853ead">UniformizationGen</a> (const Matrix &amp;Q, const VectorIn &amp;pi0, VectorOut &amp;piExpQ, VectorOut *p_piIntExpQ, const char *fg, const double epsilon, const KolmogorovEquationDirection ked, const RowSelector &amp;rows, const ColSelector &amp;cols, <a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;printOut)</td></tr>
<tr class="separator:ga7412c545617e7b9559a780bcd3853ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01346e49b7e01fba408ff761c2550901"><td class="memTemplParams" colspan="2"><a id="ga01346e49b7e01fba408ff761c2550901"></a>
template&lt;class Matrix , class VectorIn , class VectorOut , class RowSelector , class ColSelector &gt; </td></tr>
<tr class="memitem:ga01346e49b7e01fba408ff761c2550901"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>UniformizationDet</b> (const Matrix &amp;Q, const VectorIn &amp;pi0, VectorOut &amp;piExpQ, VectorOut *p_piIntExpQ, double t, const double epsilon, const KolmogorovEquationDirection ked, const RowSelector &amp;rows, const ColSelector &amp;cols, <a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;printOut)</td></tr>
<tr class="separator:ga01346e49b7e01fba408ff761c2550901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffa34b3a829c4177f4d2dc981cd8840a"><td class="memItemLeft" align="right" valign="top"><a id="gaffa34b3a829c4177f4d2dc981cd8840a"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>dfs_visit_node::dfs_visit_node</b> (size_t _v, DfsVisitState vs)</td></tr>
<tr class="separator:gaffa34b3a829c4177f4d2dc981cd8840a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcd17113b511472477e2277621ec1f55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gabcd17113b511472477e2277621ec1f55">multiorder_vector::add</a> (size_t i, double v)</td></tr>
<tr class="memdesc:gabcd17113b511472477e2277621ec1f55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a value into the vector at the specified position.  <a href="#gabcd17113b511472477e2277621ec1f55">More...</a><br /></td></tr>
<tr class="separator:gabcd17113b511472477e2277621ec1f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9964f03174e7b9d5b12e57b1328d88e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga9964f03174e7b9d5b12e57b1328d88e0">full_element_selector::full_element_selector</a> (size_t _N)</td></tr>
<tr class="separator:ga9964f03174e7b9d5b12e57b1328d88e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5f5417d8e7e665c447d4b064a6410001"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#ga5f5417d8e7e665c447d4b064a6410001">full_element_selector::isSelected</a> (size_t k) const</td></tr>
<tr class="separator:ga5f5417d8e7e665c447d4b064a6410001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf33c8a21bfec18b9eba001e258ef0c67"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gaf33c8a21bfec18b9eba001e258ef0c67">full_element_selector::count</a> () const</td></tr>
<tr class="separator:gaf33c8a21bfec18b9eba001e258ef0c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd851a27d2bb54960150ffe906ea2705"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d22/group__Numerical.html#gabd851a27d2bb54960150ffe906ea2705">full_element_selector::operator[]</a> (size_t n) const</td></tr>
<tr class="separator:gabd851a27d2bb54960150ffe906ea2705"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga0ff9efcfa9092cc8805697e337bdcabc"><td class="memItemLeft" align="right" valign="top"><a id="ga0ff9efcfa9092cc8805697e337bdcabc"></a>
const sccindex_t&#160;</td><td class="memItemRight" valign="bottom"><b>TRANSIENT_COMPONENT</b> = sccindex_t(-1)</td></tr>
<tr class="separator:ga0ff9efcfa9092cc8805697e337bdcabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a id="gabcd17113b511472477e2277621ec1f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabcd17113b511472477e2277621ec1f55">&#9670;&nbsp;</a></span>add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void multiorder_vector::add </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a value into the vector at the specified position. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>vector row </td></tr>
    <tr><td class="paramname">v</td><td>value added to row i </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2c091d71c07cdba65e14427039511de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c091d71c07cdba65e14427039511de4">&#9670;&nbsp;</a></span>add_prod_matvec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorX , class VectorOut , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; add_prod_matvec </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorX &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fast matrix * vector product <img class="formulaInl" alt="$ y += A \cdot x $" src="../../form_4.png"/>, added to <em>y</em>. y must be a different vector than x </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Matrix factor. </td></tr>
    <tr><td class="paramname">x</td><td>Vector factor. </td></tr>
    <tr><td class="paramname">rows</td><td>Rows of (y,<a class="el" href="../../d2/d88/classA.html">A</a>,x) selected for the computation. </td></tr>
    <tr><td class="paramname">cols</td><td>Columns of (y,<a class="el" href="../../d2/d88/classA.html">A</a>,x) selected for the computation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>

</div>
</div>
<a id="ga75338d4b8b76a958b2d19196f84e2836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75338d4b8b76a958b2d19196f84e2836">&#9670;&nbsp;</a></span>add_prod_vecmat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorX , class VectorOut , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; add_prod_vecmat </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorX &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fast matrix * vector product <img class="formulaInl" alt="$ y = A \cdot x $" src="../../form_1.png"/>. y must be a different vector than x </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Matrix factor. </td></tr>
    <tr><td class="paramname">x</td><td>Vector factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. Fast vector * matrix product <img class="formulaInl" alt="$ y = x \cdot A $" src="../../form_2.png"/>. y must be a different vector than x </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. </td></tr>
    <tr><td class="paramname">x</td><td>Vector factor. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Matrix factor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. Fast vector * matrix product <img class="formulaInl" alt="$ y += x \cdot A $" src="../../form_3.png"/>, added to <em>y</em>. y must be a different vector than x </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. </td></tr>
    <tr><td class="paramname">x</td><td>Vector factor. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Matrix factor. </td></tr>
    <tr><td class="paramname">rows</td><td>Rows of (y,<a class="el" href="../../d2/d88/classA.html">A</a>,x) selected for the computation. </td></tr>
    <tr><td class="paramname">cols</td><td>Columns of (y,<a class="el" href="../../d2/d88/classA.html">A</a>,x) selected for the computation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>

</div>
</div>
<a id="ga13fac47d7d0ae93958c42c3da75ecfd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13fac47d7d0ae93958c42c3da75ecfd8">&#9670;&nbsp;</a></span>add_vec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorIn , class VectorOut , class Selector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; add_vec </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorIn &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a vector into another: <img class="formulaInl" alt="$ y += x $" src="../../form_11.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. </td></tr>
    <tr><td class="paramname">x</td><td>Source vector </td></tr>
    <tr><td class="paramname">rows</td><td>Selected elements of <em>x</em> added to <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>

</div>
</div>
<a id="ga179f3f76a0e789ceaa76bab6c5a7ab32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga179f3f76a0e789ceaa76bab6c5a7ab32">&#9670;&nbsp;</a></span>add_vec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorOut , class Selector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; add_vec </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a constant factor to every vector elements: <img class="formulaInl" alt="$ y += c $" src="../../form_13.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. Must be initialized. </td></tr>
    <tr><td class="paramname">c</td><td>Constant factor. </td></tr>
    <tr><td class="paramname">rows</td><td>Selected elements of <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>

</div>
</div>
<a id="ga366b93973649e254cce28c63f703e2e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga366b93973649e254cce28c63f703e2e1">&#9670;&nbsp;</a></span>assign_mult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorOut , class VectorIn , class Selector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; assign_mult </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorIn &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fast vector x scalar product with: <img class="formulaInl" alt="$ y = (c \cdot x) $" src="../../form_8.png"/>. <em>y</em> and <em>x</em> may be the same vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. </td></tr>
    <tr><td class="paramname">c</td><td>Constant factor. </td></tr>
    <tr><td class="paramname">x</td><td>Source vector. </td></tr>
    <tr><td class="paramname">rows</td><td>Selected rows of <em>x</em> and <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>

</div>
</div>
<a id="ga2eac7de08404d3176345de87d6ab2bf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2eac7de08404d3176345de87d6ab2bf2">&#9670;&nbsp;</a></span>BackSubstitution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatA , class MatD , class VecB , class VecX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BackSubstitution </td>
          <td>(</td>
          <td class="paramtype">const MatA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatD &amp;&#160;</td>
          <td class="paramname"><em>Diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VecB &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VecX &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do a back-substitution with the Upper Triangular <a class="el" href="../../d2/d88/classA.html">A</a> matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Upper part of the matrix in the back-substitution method. </td></tr>
    <tr><td class="paramname">Diag</td><td>Diagonal used in he back-substitution method. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector. </td></tr>
    <tr><td class="paramname">x</td><td>Output vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga31d7722a852d33dbe4f14484a3f11ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31d7722a852d33dbe4f14484a3f11ea9">&#9670;&nbsp;</a></span>BackwardGaussSeidelIteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorIn , class VectorB , class VectorD , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BackwardGaussSeidelIteration </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorIn &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorB &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorD &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>max_err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Backward Gauss-Seidel iteration for a linear equation system <img class="formulaInl" alt="$(A+Id) \cdot x=b$" src="../../form_24.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Matrix with the linear equation system. </td></tr>
    <tr><td class="paramname">x</td><td>Solution vector. </td></tr>
    <tr><td class="paramname">b</td><td>Column vector b. </td></tr>
    <tr><td class="paramname">d</td><td>Diagonal vector added to <a class="el" href="../../d2/d88/classA.html">A</a>. </td></tr>
    <tr><td class="paramname">omega</td><td>Over-relaxation parameter (SOR method), 0&lt;<em>omega&lt;2</em>. </td></tr>
    <tr><td class="paramname">max_err</td><td>On return contains the maximum difference between elements of <em>x</em> and <em>x'</em>. </td></tr>
    <tr><td class="paramname">x_norm</td><td>Norm-1 of <em>x</em> after this Jacobi iteration. </td></tr>
    <tr><td class="paramname">rows</td><td>Rows of (<a class="el" href="../../d2/d88/classA.html">A</a>,x,b) selected for the computation. </td></tr>
    <tr><td class="paramname">cols</td><td>Columns of (<a class="el" href="../../d2/d88/classA.html">A</a>,x,b) selected for the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method performs a single iteration of the backward Gauss-Seidel method over <em>x</em> for linear system <img class="formulaInl" alt="$(A+Id) \cdot x=b$" src="../../form_24.png"/> with the formula: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x' = (D+U)^{-1} \cdot (b - Lx) \]" src="../../form_29.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x' = D^{-1} \cdot (b - (Ux' + Lx)) \]" src="../../form_30.png"/>
</p>
 with <img class="formulaInl" alt="$ (A+Id)=D+L+U $" src="../../form_26.png"/> the <em>(<a class="el" href="../../de/d26/classD.html">D</a>,L,U)</em> decomposition of the linear equation system matrix. <br />
 Values of <em>x</em> not selected by <em>rows</em> remains unchanged. </dd></dl>

</div>
</div>
<a id="gad49e50bc2a7b246912e9853d2ee1fec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad49e50bc2a7b246912e9853d2ee1fec9">&#9670;&nbsp;</a></span>BackwardGaussSeidelTransIteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorIn , class VectorB , class VectorD , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BackwardGaussSeidelTransIteration </td>
          <td>(</td>
          <td class="paramtype">VectorIn &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorB &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorD &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorIn &amp;&#160;</td>
          <td class="paramname"><em>xLU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>startOfU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>max_err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Backward Gauss-Seidel iteration for a linear equation system <img class="formulaInl" alt="$x^T \cdot (A+Id)^T=b^T$" src="../../form_31.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Solution vector. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Matrix with the linear equation system (transposed). </td></tr>
    <tr><td class="paramname">b</td><td>Column vector b. </td></tr>
    <tr><td class="paramname">d</td><td>Diagonal vector added to <a class="el" href="../../d2/d88/classA.html">A</a>. </td></tr>
    <tr><td class="paramname">omega</td><td>Over-relaxation parameter (SOR method), 0&lt;<em>omega&lt;2</em>. </td></tr>
    <tr><td class="paramname">xLU</td><td>Auxiliary vector needed in the iterative method. </td></tr>
    <tr><td class="paramname">startOfU</td><td>Starting index of the U rows in <a class="el" href="../../d2/d88/classA.html">A</a>. </td></tr>
    <tr><td class="paramname">max_err</td><td>On return contains the maximum difference between elements. of <em>x</em> and <em>x'</em>. </td></tr>
    <tr><td class="paramname">x_norm</td><td>Norm-1 of <em>x</em> after this Jacobi iteration. </td></tr>
    <tr><td class="paramname">rows</td><td>Rows of (x,<a class="el" href="../../d2/d88/classA.html">A</a>,b) selected for the computation. </td></tr>
    <tr><td class="paramname">cols</td><td>Columns of (x,<a class="el" href="../../d2/d88/classA.html">A</a>,b) selected for the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method performs a single iteration of the Jacobi method over <em>x</em> for linear system <img class="formulaInl" alt="$x^T \cdot (A+Id)^T=b^T$" src="../../form_31.png"/> with the formula: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x' = (b - xU) \cdot (D+L)^{-1} \]" src="../../form_36.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x' = (b - (x'L + xU)) \cdot D^{-1} \]" src="../../form_37.png"/>
</p>
 with <img class="formulaInl" alt="$ (A+Id)^T=D+L+U $" src="../../form_33.png"/> the <em>(<a class="el" href="../../de/d26/classD.html">D</a>,L,U)</em> decomposition of the transposed linear equation system matrix. <br />
 Values of <em>x</em> not selected by <em>rows</em> remains unchanged. <br />
 <a class="el" href="../../d2/d88/classA.html">A</a> Backward Gauss-Seidel transposed iteration is equivalent to a backward Gauss-Seidel iteration on a transposed matrix. Note that <code>U</code> and <code>L</code> in the formula above are refersed compared to the backward Gauss-Seidel definition, because of the transpose of <em><a class="el" href="../../d2/d88/classA.html">A</a></em>. </dd></dl>

</div>
</div>
<a id="gac6bf5ffc484217fab980476848108979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac6bf5ffc484217fab980476848108979">&#9670;&nbsp;</a></span>BottomStronglyConnectedComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void BottomStronglyConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/dc9/classBSCC.html">BSCC</a> &amp;&#160;</td>
          <td class="paramname"><em>bscc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the Bottom Strongly Connected Components of a sparse matrix graph. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix graph (as an adjacency list) </td></tr>
    <tr><td class="paramname">bscc</td><td>On return contains the <a class="el" href="../../de/dc9/classBSCC.html" title="BSCC analysis of a Markov chain. ">BSCC</a> structure initialized. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae49027fe4cfaab6360fc9008112a4e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae49027fe4cfaab6360fc9008112a4e7f">&#9670;&nbsp;</a></span>compress_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void compress_matrix </td>
          <td>(</td>
          <td class="paramtype">ublas::compressed_matrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/db1/classmatrix__map.html">matrix_map</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compress a <a class="el" href="../../d4/db1/classmatrix__map.html" title="Intermediate class that implements a matrix-like interface for filling a matrix in sparse order...">matrix_map</a> instance into a ublas::compressed_matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Destination matrix (will be cleared before the compression). </td></tr>
    <tr><td class="paramname">src</td><td>Source mapped matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadbad51835d91dfebb7cf1fdd0b2bf4e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbad51835d91dfebb7cf1fdd0b2bf4e3">&#9670;&nbsp;</a></span>copy_vec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorIn , class VectorOut , class Selector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; copy_vec </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorIn &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fast vector product: <img class="formulaInl" alt="$ y = y \cdot c $" src="../../form_9.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. Must be initialized. </td></tr>
    <tr><td class="paramname">c</td><td>Constant factor. </td></tr>
    <tr><td class="paramname">rows</td><td>Selected elements of <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. Copy a vector: <img class="formulaInl" alt="$ y = x $" src="../../form_10.png"/>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. </td></tr>
    <tr><td class="paramname">x</td><td>Source vector </td></tr>
    <tr><td class="paramname">rows</td><td>Selected elements of <em>x</em> copied to <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>

</div>
</div>
<a id="gaf33c8a21bfec18b9eba001e258ef0c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf33c8a21bfec18b9eba001e258ef0c67">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t full_element_selector::count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the selected elements count. </p><dl class="section return"><dt>Returns</dt><dd>The range value N. </dd></dl>

</div>
</div>
<a id="ga2ee0feca6dda953b6290bc7cb82846a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ee0feca6dda953b6290bc7cb82846a1">&#9670;&nbsp;</a></span>div_vec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorOut , class Selector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; div_vec </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fast vector division: <img class="formulaInl" alt="$ y = y / c $" src="../../form_12.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. Must be initialized. </td></tr>
    <tr><td class="paramname">c</td><td>Constant factor. </td></tr>
    <tr><td class="paramname">rows</td><td>Selected elements of <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>

</div>
</div>
<a id="gaa47302b338072cff21819c2e8c5c6d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa47302b338072cff21819c2e8c5c6d74">&#9670;&nbsp;</a></span>FastTranspose() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ublas::compressed_matrix&lt;T&gt;&amp; FastTranspose </td>
          <td>(</td>
          <td class="paramtype">const ublas::compressed_matrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ublas::compressed_matrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast transposition of a sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Input matrix. </td></tr>
    <tr><td class="paramname">out</td><td>Matrix that will hold the transpose of <em>in</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference of the <em>out</em> matrix. </dd></dl>

</div>
</div>
<a id="gace17e98e229747a7940e082eec16ee83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace17e98e229747a7940e082eec16ee83">&#9670;&nbsp;</a></span>FastTranspose() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ublas::matrix&lt;T&gt;&amp; FastTranspose </td>
          <td>(</td>
          <td class="paramtype">const ublas::matrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ublas::matrix&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fast transposition of a sparse matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">in</td><td>Input matrix. </td></tr>
    <tr><td class="paramname">out</td><td>Matrix that will hold the transpose of <em>in</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference of the <em>out</em> matrix. </dd></dl>

</div>
</div>
<a id="gae4370325ccac4572c34024e8cfeffab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae4370325ccac4572c34024e8cfeffab6">&#9670;&nbsp;</a></span>FG_Finder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FG_Finder </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/da5/structFoxGlynnWeights.html">FoxGlynnWeights</a> &amp;&#160;</td>
          <td class="paramname"><em>fgw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>W_M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/ddb/group__Numeric.html#ga0822d01c051e2b76c48c9ae19b07a471">VerboseLevel</a>&#160;</td>
          <td class="paramname"><em>verboseLvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fox-Glynn's Finder algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>Poisson rate. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Error tolerance (should be &gt;= 1e-10). </td></tr>
    <tr><td class="paramname">tau</td><td>Underflow threshold. </td></tr>
    <tr><td class="paramname">omega</td><td>Overflow threshold. </td></tr>
    <tr><td class="paramname">fgw</td><td>Fox-Glynn weight vector storage &amp; truncation points. </td></tr>
    <tr><td class="paramname">W_M</td><td>On return contains the w(M) weight. </td></tr>
    <tr><td class="paramname">verboseLvl</td><td>Print informations to the stdout. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if FG_Finder couldn't find a valid [L,R] interval.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>FG_Finder findes the left and right truncation points for the Poisson distribution with coefficient lambda. It returns false if the underflow conditions are not satisfied. On return, the (L, R, w_M) fields of fgw are filled. </dd></dl>

</div>
</div>
<a id="ga232ce6a75582ea44e06ce13eb26fc513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga232ce6a75582ea44e06ce13eb26fc513">&#9670;&nbsp;</a></span>FG_Weighter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool FG_Weighter </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>tau</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/da5/structFoxGlynnWeights.html">FoxGlynnWeights</a> &amp;&#160;</td>
          <td class="paramname"><em>fgw</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/ddb/group__Numeric.html#ga0822d01c051e2b76c48c9ae19b07a471">VerboseLevel</a>&#160;</td>
          <td class="paramname"><em>verboseLvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fox-Glynn's Weighter algorithm. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lambda</td><td>Poisson rate </td></tr>
    <tr><td class="paramname">epsilon</td><td>Error tolerance. epsilon should be &gt;= 1e-10 </td></tr>
    <tr><td class="paramname">tau</td><td>Underflow threshold </td></tr>
    <tr><td class="paramname">omega</td><td>Overflow threshold </td></tr>
    <tr><td class="paramname">fgw</td><td>Fox-Glynn weight vector storage &amp; truncation points </td></tr>
    <tr><td class="paramname">verboseLvl</td><td>Print informations to the stdout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if weights hav been computed correctly, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>FG_Weighter computes the Poisson probabilities with rate lambda, finding the relevant left and right tails of the distribution. Returns true if the computation succeeded, with the fields in fgw initialized. </dd></dl>

</div>
</div>
<a id="ga245530c619f15f689303b0dfb6827a11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga245530c619f15f689303b0dfb6827a11">&#9670;&nbsp;</a></span>filter_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void filter_matrix </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>inM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>outM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new matrix outM which has only the entries in the selected rows and columns, while preserving the dimensions of the input matrix </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inM</td><td>Input matrix. </td></tr>
    <tr><td class="paramname">outM</td><td>Output filtered matrix. </td></tr>
    <tr><td class="paramname">rows</td><td>Filtered rows. </td></tr>
    <tr><td class="paramname">cols</td><td>Filtered columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga49bb2709656c53668edfa281d129f51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49bb2709656c53668edfa281d129f51a">&#9670;&nbsp;</a></span>ForeSubstitution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class MatA , class MatD , class VecB , class VecX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ForeSubstitution </td>
          <td>(</td>
          <td class="paramtype">const MatA &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MatD &amp;&#160;</td>
          <td class="paramname"><em>Diag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VecB &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VecX &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do a fore-substitution with the Lower Triangular <a class="el" href="../../d2/d88/classA.html">A</a> matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Upper part of the matrix in the fore-substitution method. </td></tr>
    <tr><td class="paramname">Diag</td><td>Diagonal used in he fore-substitution method. </td></tr>
    <tr><td class="paramname">b</td><td>Input vector. </td></tr>
    <tr><td class="paramname">x</td><td>Output vector. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab536f03ce513723b5abcd7fc173f8cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab536f03ce513723b5abcd7fc173f8cf4">&#9670;&nbsp;</a></span>ForwardGaussSeidelIteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorIn , class VectorB , class VectorD , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ForwardGaussSeidelIteration </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorIn &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorB &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorD &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>max_err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forward Gauss-Seidel iteration for a linear equation system <img class="formulaInl" alt="$(A+Id) \cdot x=b$" src="../../form_24.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Matrix with the linear equation system. </td></tr>
    <tr><td class="paramname">x</td><td>Solution vector. </td></tr>
    <tr><td class="paramname">b</td><td>Column vector b. </td></tr>
    <tr><td class="paramname">d</td><td>Diagonal vector added to <a class="el" href="../../d2/d88/classA.html">A</a>. </td></tr>
    <tr><td class="paramname">omega</td><td>Over-relaxation parameter (SOR method), 0&lt;<em>omega&lt;2</em>. </td></tr>
    <tr><td class="paramname">max_err</td><td>On return contains the maximum difference between elements of <em>x</em> and <em>x'</em>. </td></tr>
    <tr><td class="paramname">x_norm</td><td>Norm-1 of <em>x</em> after this Jacobi iteration. </td></tr>
    <tr><td class="paramname">rows</td><td>Rows of (<a class="el" href="../../d2/d88/classA.html">A</a>,x,b) selected for the computation. </td></tr>
    <tr><td class="paramname">cols</td><td>Columns of (<a class="el" href="../../d2/d88/classA.html">A</a>,x,b) selected for the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method performs a single iteration of the forward Gauss-Seidel method over <em>x</em> for linear system <img class="formulaInl" alt="$(A+Id) \cdot x=b$" src="../../form_24.png"/> with the formula: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x' = (D+L)^{-1} \cdot (b - Ux) \]" src="../../form_27.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x' = D^{-1} \cdot (b - (Ux + Lx')) \]" src="../../form_28.png"/>
</p>
 with <img class="formulaInl" alt="$ (A+Id)=D+L+U $" src="../../form_26.png"/> the <em>(<a class="el" href="../../de/d26/classD.html">D</a>,L,U)</em> decomposition of the linear equation system matrix. <br />
 Values of <em>x</em> not selected by <em>rows</em> remains unchanged. </dd></dl>

</div>
</div>
<a id="gacdc970def63d8b46e1ef5a1cc996b10c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacdc970def63d8b46e1ef5a1cc996b10c">&#9670;&nbsp;</a></span>ForwardGaussSeidelTransIteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorIn , class VectorB , class VectorD , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ForwardGaussSeidelTransIteration </td>
          <td>(</td>
          <td class="paramtype">VectorIn &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorB &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorD &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorIn &amp;&#160;</td>
          <td class="paramname"><em>xLU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>startOfU</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>max_err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forward Gauss-Seidel iteration for a linear equation system <img class="formulaInl" alt="$x^T \cdot (A+Id)^T=b^T$" src="../../form_31.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Solution vector. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Matrix with the linear equation system (transposed). </td></tr>
    <tr><td class="paramname">b</td><td>Column vector b. </td></tr>
    <tr><td class="paramname">d</td><td>Diagonal vector added to <a class="el" href="../../d2/d88/classA.html">A</a>. </td></tr>
    <tr><td class="paramname">omega</td><td>Over-relaxation parameter (SOR method), 0&lt;<em>omega&lt;2</em>. </td></tr>
    <tr><td class="paramname">xLU</td><td>Auxiliary vector needed in the iterative method. </td></tr>
    <tr><td class="paramname">startOfU</td><td>Starting index of the U rows in <a class="el" href="../../d2/d88/classA.html">A</a>. </td></tr>
    <tr><td class="paramname">max_err</td><td>On return contains the maximum difference between elements. of <em>x</em> and <em>x'</em>. </td></tr>
    <tr><td class="paramname">x_norm</td><td>Norm-1 of <em>x</em> after this Jacobi iteration. </td></tr>
    <tr><td class="paramname">rows</td><td>Rows of (x,<a class="el" href="../../d2/d88/classA.html">A</a>,b) selected for the computation. </td></tr>
    <tr><td class="paramname">cols</td><td>Columns of (x,<a class="el" href="../../d2/d88/classA.html">A</a>,b) selected for the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method performs a single iteration of the Jacobi method over <em>x</em> for linear system <img class="formulaInl" alt="$x^T \cdot (A+Id)^T=b^T$" src="../../form_31.png"/> with the formula: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x' = (b - xL) \cdot (D+U)^{-1} \]" src="../../form_34.png"/>
</p>
 <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x' = (b - (xL + x'U)) \cdot D^{-1} \]" src="../../form_35.png"/>
</p>
 with <img class="formulaInl" alt="$ (A+Id)^T=D+L+U $" src="../../form_33.png"/> the <em>(<a class="el" href="../../de/d26/classD.html">D</a>,L,U)</em> decomposition of the transposed linear equation system matrix. <br />
 Values of <em>x</em> not selected by <em>rows</em> remains unchanged. <br />
 <a class="el" href="../../d2/d88/classA.html">A</a> Forward Gauss-Seidel transposed iteration is equivalent to a formard Gauss-Seidel iteration on a transposed matrix. Note that <code>U</code> and <code>L</code> in the formula above are refersed compared to the forward Gauss-Seidel definition, because of the transpose of <em><a class="el" href="../../d2/d88/classA.html">A</a></em>. </dd></dl>

</div>
</div>
<a id="ga9964f03174e7b9d5b12e57b1328d88e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9964f03174e7b9d5b12e57b1328d88e0">&#9670;&nbsp;</a></span>full_element_selector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">full_element_selector::full_element_selector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>_N</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize a <a class="el" href="../../da/df2/classfull__element__selector.html">full_element_selector</a> instance. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">_N</td><td>number of elements in range [0, N). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab702b27c6cc6a5252e14919b984a4770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab702b27c6cc6a5252e14919b984a4770">&#9670;&nbsp;</a></span>ILU0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix::value_type ILU0 </td>
          <td>(</td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/ddb/group__Numeric.html#ga0822d01c051e2b76c48c9ae19b07a471">VerboseLevel</a>&#160;</td>
          <td class="paramname"><em>verboseLvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Incomplete LU factorization with 0 level of fill-ins. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>Input matrix. Overwritten by the algorithm </td></tr>
    <tr><td class="paramname">verboseLvl</td><td>Verbose level of the method. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The determinant of the ILU matrix. </dd></dl>

</div>
</div>
<a id="ga2f142fe5a7e709d2f6f54d0b8a149820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f142fe5a7e709d2f6f54d0b8a149820">&#9670;&nbsp;</a></span>ILUTK()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void ILUTK </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ublas::compressed_matrix&lt; typename Matrix::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>outP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Matrix::value_type&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d9/ddb/group__Numeric.html#ga0822d01c051e2b76c48c9ae19b07a471">VerboseLevel</a>&#160;</td>
          <td class="paramname"><em>verboseLvl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Incomplete LU factorization with threshold and K maximum fill-ins. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Input matrix. </td></tr>
    <tr><td class="paramname">outP</td><td>Output preconditioner matrix. </td></tr>
    <tr><td class="paramname">threshold</td><td>Relative threshold of the dropping strategy. </td></tr>
    <tr><td class="paramname">K</td><td>Maximum number of entries kept in L and in U. </td></tr>
    <tr><td class="paramname">verboseLvl</td><td>Verbose level of the method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2769e0ee80cb0d7ae3d23234da44604d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2769e0ee80cb0d7ae3d23234da44604d">&#9670;&nbsp;</a></span>Inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class E &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ublas::matrix&lt;typename E::value_type&gt; Inverse </td>
          <td>(</td>
          <td class="paramtype">const ublas::matrix_expression&lt; E &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix inversion. Works for dense matrices with the LU factorization of ublas </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>Input matrix that will be inverted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The inverse of <em>input</em>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thorws an exception if the <em>input</em> matrix is singular. </dd></dl>

</div>
</div>
<a id="ga5f5417d8e7e665c447d4b064a6410001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f5417d8e7e665c447d4b064a6410001">&#9670;&nbsp;</a></span>isSelected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool full_element_selector::isSelected </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test if a value <em>k</em> is in the selected range. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">k</td><td>Tested value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the element k is in range [0, N), with 0&lt;=k&lt;N. </dd></dl>

</div>
</div>
<a id="ga370c44e673aa8f028fba38d396a5b6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga370c44e673aa8f028fba38d396a5b6c1">&#9670;&nbsp;</a></span>JacobiIteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorIn , class VectorB , class VectorD , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void JacobiIteration </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorIn &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorB &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorD &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorIn &amp;&#160;</td>
          <td class="paramname"><em>x_next</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>max_err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Jacobi iteration for a linear equation system <img class="formulaInl" alt="$(A+Id) \cdot x=b$" src="../../form_24.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Matrix with the linear equation system. </td></tr>
    <tr><td class="paramname">x</td><td>Solution vector. </td></tr>
    <tr><td class="paramname">b</td><td>Column vector b. </td></tr>
    <tr><td class="paramname">d</td><td>Diagonal vector added to <a class="el" href="../../d2/d88/classA.html">A</a>. </td></tr>
    <tr><td class="paramname">omega</td><td>Over-relaxation parameter (JOR method), 0&lt;<em>omega&lt;2</em>. </td></tr>
    <tr><td class="paramname">x_next</td><td>Auxiliary vector needed in the Jacobi method. </td></tr>
    <tr><td class="paramname">max_err</td><td>On return contains the maximum difference between elements of <em>x</em> and <em>x'</em>. </td></tr>
    <tr><td class="paramname">x_norm</td><td>Norm-1 of <em>x</em> after this Jacobi iteration. </td></tr>
    <tr><td class="paramname">rows</td><td>Rows of (<a class="el" href="../../d2/d88/classA.html">A</a>,x,b) selected for the computation. </td></tr>
    <tr><td class="paramname">cols</td><td>Columns of (<a class="el" href="../../d2/d88/classA.html">A</a>,x,b) selected for the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method performs a single iteration of the Jacobi method over <em>x</em> for linear system <img class="formulaInl" alt="$(A+Id) \cdot x=b$" src="../../form_24.png"/> with the formula: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x' = D^{-1} \cdot (b - (L+U)x) \]" src="../../form_25.png"/>
</p>
 with <img class="formulaInl" alt="$ (A+Id)=D+L+U $" src="../../form_26.png"/> the <em>(<a class="el" href="../../de/d26/classD.html">D</a>,L,U)</em> decomposition of the linear equation system matrix. <br />
 Values of <em>x</em> not selected by <em>rows</em> remains unchanged. </dd></dl>

</div>
</div>
<a id="ga542b7d72281839d39d2439ae3ca3ab91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga542b7d72281839d39d2439ae3ca3ab91">&#9670;&nbsp;</a></span>JacobiTransIteration()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorIn , class VectorB , class VectorD , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void JacobiTransIteration </td>
          <td>(</td>
          <td class="paramtype">VectorIn &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorB &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorD &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>omega</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorIn &amp;&#160;</td>
          <td class="paramname"><em>sigma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>max_err</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>x_norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Jacobi iteration for a linear equation system <img class="formulaInl" alt="$x^T \cdot (A+Id)^T=b^T$" src="../../form_31.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Solution vector. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Matrix with the linear equation system (transposed). </td></tr>
    <tr><td class="paramname">b</td><td>Column vector b. </td></tr>
    <tr><td class="paramname">d</td><td>Diagonal vector added to <a class="el" href="../../d2/d88/classA.html">A</a>. </td></tr>
    <tr><td class="paramname">omega</td><td>Over-relaxation parameter (JOR method), 0&lt;<em>omega&lt;2</em>. </td></tr>
    <tr><td class="paramname">sigma</td><td>Auxiliary vector needed in the Jacobi method. </td></tr>
    <tr><td class="paramname">max_err</td><td>On return contains the maximum difference between elements. of <em>x</em> and <em>x'</em>. </td></tr>
    <tr><td class="paramname">x_norm</td><td>Norm-1 of <em>x</em> after this Jacobi iteration. </td></tr>
    <tr><td class="paramname">rows</td><td>Rows of (x,<a class="el" href="../../d2/d88/classA.html">A</a>,b) selected for the computation. </td></tr>
    <tr><td class="paramname">cols</td><td>Columns of (x,<a class="el" href="../../d2/d88/classA.html">A</a>,b) selected for the computation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method performs a single iteration of the Jacobi method over <em>x</em> for linear system <img class="formulaInl" alt="$x^T \cdot (A+Id)^T=b^T$" src="../../form_31.png"/> with the formula: <p class="formulaDsp">
<img class="formulaDsp" alt="\[ x' = (b - x(L+U)) \cdot D^{-1} \]" src="../../form_32.png"/>
</p>
 with <img class="formulaInl" alt="$ (A+Id)^T=D+L+U $" src="../../form_33.png"/> the <em>(<a class="el" href="../../de/d26/classD.html">D</a>,L,U)</em> decomposition of the transposed linear equation system matrix. <br />
 Values of <em>x</em> not selected by <em>rows</em> remains unchanged. </dd></dl>

</div>
</div>
<a id="ga87db4bad71c1ae512bcf0c24bb15170f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87db4bad71c1ae512bcf0c24bb15170f">&#9670;&nbsp;</a></span>LinearSolve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorIn , class VectorB , class VectorD , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool LinearSolve </td>
          <td>(</td>
          <td class="paramtype">VectorIn &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorB &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorD &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KolmogorovEquationDirection&#160;</td>
          <td class="paramname"><em>ked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d03/structSolverParams.html">SolverParams</a> &amp;&#160;</td>
          <td class="paramname"><em>spar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;&#160;</td>
          <td class="paramname"><em>printOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorIn *&#160;</td>
          <td class="paramname"><em>init_x0</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solves a system of linear equations in the form <img class="formulaInl" alt="$x^T \cdot (A+Id)^T=b^T$" src="../../form_31.png"/>. <br />
 Note that this is the transposed of the standard system <img class="formulaInl" alt="$(A+Id) \cdot x=b$" src="../../form_24.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Solution vector. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Matrix with the linear equation system (transposed). </td></tr>
    <tr><td class="paramname">b</td><td>Column vector b. </td></tr>
    <tr><td class="paramname">d</td><td>Diagonal vector added to <a class="el" href="../../d2/d88/classA.html">A</a>. </td></tr>
    <tr><td class="paramname">ked</td><td>Direction of the equation system. </td></tr>
    <tr><td class="paramname">spar</td><td>Algorithm parameters. </td></tr>
    <tr><td class="paramname">printOut</td><td>Print informations on the console. </td></tr>
    <tr><td class="paramname">rows</td><td>Rows of (x,<a class="el" href="../../d2/d88/classA.html">A</a>,b) selected for the computation. </td></tr>
    <tr><td class="paramname">cols</td><td>Columns of (x,<a class="el" href="../../d2/d88/classA.html">A</a>,b) selected for the computation. </td></tr>
    <tr><td class="paramname">init_x0</td><td>Initial distribution of x(0), (nullptr for a uniform vector). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the method converges in less than <em>maxIters</em> iterations.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>On return, the x[] elements not selected by (rows) are unchanged. </dd></dl>

</div>
</div>
<a id="ga9c3bb1edfd13e82686e9ea9d3491e45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c3bb1edfd13e82686e9ea9d3491e45b">&#9670;&nbsp;</a></span>mult_vec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorOut , class Selector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; mult_vec </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fast vector product: <img class="formulaInl" alt="$ y = y \cdot c $" src="../../form_9.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. Must be initialized. </td></tr>
    <tr><td class="paramname">c</td><td>Constant factor. </td></tr>
    <tr><td class="paramname">rows</td><td>Selected elements of <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>

</div>
</div>
<a id="ga35f155ed1007f2039c2a2e4df4dd26fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga35f155ed1007f2039c2a2e4df4dd26fe">&#9670;&nbsp;</a></span>norm_1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorIn , class Selector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double norm_1 </td>
          <td>(</td>
          <td class="paramtype">VectorIn &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>1-Norm: <img class="formulaInl" alt="$ c = |x|_1 $" src="../../form_15.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Source vector. Must be initialized. </td></tr>
    <tr><td class="paramname">rows</td><td>Selected elements of . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The 1-norm of <em>x</em>. </dd></dl>

</div>
</div>
<a id="ga3ee6c552b6a423ee79a51edfce5e65b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ee6c552b6a423ee79a51edfce5e65b6">&#9670;&nbsp;</a></span>NormInf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Matrix::value_type NormInf </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Infinity norm for matrices. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Input matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The infinity norm of <em><a class="el" href="../../d2/d88/classA.html">A</a></em>. </dd></dl>

</div>
</div>
<a id="gabd851a27d2bb54960150ffe906ea2705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd851a27d2bb54960150ffe906ea2705">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t full_element_selector::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the n-th selected element. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Selected element index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Simply returns n. </dd></dl>

</div>
</div>
<a id="ga656ef9246f1217485db9ec682153a352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga656ef9246f1217485db9ec682153a352">&#9670;&nbsp;</a></span>plus_assign_mult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorOut , class VectorIn , class Selector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; plus_assign_mult </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorIn &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fast vector product with assignment: <img class="formulaInl" alt="$ y = y + (c \cdot x) $" src="../../form_7.png"/>. <em>y</em> and <em>x</em> may be the same vector. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. Must be initialized. </td></tr>
    <tr><td class="paramname">c</td><td>Constant factor. </td></tr>
    <tr><td class="paramname">x</td><td>Source vector. </td></tr>
    <tr><td class="paramname">rows</td><td>Selected rows of <em>x</em> and <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>

</div>
</div>
<a id="ga3203ef58d792aefffa23cfe4b3c92002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3203ef58d792aefffa23cfe4b3c92002">&#9670;&nbsp;</a></span>print_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ostream_t , class Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void print_matrix </td>
          <td>(</td>
          <td class="paramtype">ostream_t &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print out a matrix onto the specified stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Output stream. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Printed matrix. </td></tr>
    <tr><td class="paramname">name</td><td>Name of the matrix. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6d4ac3e67017bd2a4dcbaf9c6fde802a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d4ac3e67017bd2a4dcbaf9c6fde802a">&#9670;&nbsp;</a></span>prod_invDiagM_M_vec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorIn , class VectorOut , class Matrix , class RowSelector , class ColSelector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; prod_invDiagM_M_vec </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>outVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorIn &amp;&#160;</td>
          <td class="paramname"><em>inVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix * vector product with discretization of <em>M:</em> <img class="formulaInl" alt="$ out += - (diag^{-1}(M)) \times M \cdot in $" src="../../form_22.png"/>. y must be a different vector than x. The diag operation is safe and works also with zero diagonals. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. </td></tr>
    <tr><td class="paramname">x</td><td>Vector factor. </td></tr>
    <tr><td class="paramname">M</td><td>Matrix factor. </td></tr>
    <tr><td class="paramname">rows</td><td>Rows of (y,<a class="el" href="../../d2/d88/classA.html">A</a>,x) selected for the computation. </td></tr>
    <tr><td class="paramname">cols</td><td>Columns of (y,<a class="el" href="../../d2/d88/classA.html">A</a>,x) selected for the computation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>

</div>
</div>
<a id="ga21687d83fa40e07c1b336380c2177c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga21687d83fa40e07c1b336380c2177c4f">&#9670;&nbsp;</a></span>prod_matvec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorX , class VectorOut , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; prod_matvec </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorX &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fast matrix * vector product <img class="formulaInl" alt="$ y = A \cdot x $" src="../../form_1.png"/>. y must be a different vector than x </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Matrix factor. </td></tr>
    <tr><td class="paramname">x</td><td>Vector factor. </td></tr>
    <tr><td class="paramname">rows</td><td>Rows of (y,<a class="el" href="../../d2/d88/classA.html">A</a>,x) selected for the computation. </td></tr>
    <tr><td class="paramname">cols</td><td>Columns of (y,<a class="el" href="../../d2/d88/classA.html">A</a>,x) selected for the computation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>

</div>
</div>
<a id="gaf94b68aee8a871e6977495d212985b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf94b68aee8a871e6977495d212985b23">&#9670;&nbsp;</a></span>prod_matvec_diag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorX , class VectorD , class VectorOut , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; prod_matvec_diag </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorD &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorX &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fast matrix * vector product <img class="formulaInl" alt="$ y = (A+Id) \cdot x $" src="../../form_5.png"/>. <br />
y must be a different vector than x </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Matrix factor. </td></tr>
    <tr><td class="paramname">d</td><td>Diagonal vector added to <a class="el" href="../../d2/d88/classA.html">A</a> </td></tr>
    <tr><td class="paramname">x</td><td>Vector factor. </td></tr>
    <tr><td class="paramname">rows</td><td>Rows of (y,<a class="el" href="../../d2/d88/classA.html">A</a>,d,x) selected for the computation. </td></tr>
    <tr><td class="paramname">cols</td><td>Columns of (y,<a class="el" href="../../d2/d88/classA.html">A</a>,d,x) selected for the computation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><em><a class="el" href="../../d2/d88/classA.html">A</a></em> must be a N*N square matrix. Rectangular matrices are not supported </dd></dl>

</div>
</div>
<a id="ga55ff6bca7609185e286b8eb4687f701a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga55ff6bca7609185e286b8eb4687f701a">&#9670;&nbsp;</a></span>prod_matvec_unif()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorX , class VectorOut , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; prod_matvec_unif </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorX &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply <em>x</em> with the uniformized matrix, and assign the result to <em>y:</em> <img class="formulaInl" alt="$ y = (A/lambda + I) * x $" src="../../form_20.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. Must be initialized. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Non uniformized matrix. </td></tr>
    <tr><td class="paramname">x</td><td>Source vector multiplied with the uniformized matrix </td></tr>
    <tr><td class="paramname">lambda</td><td>Uniformization coefficient </td></tr>
    <tr><td class="paramname">rows</td><td>Selected rows of <em><a class="el" href="../../d2/d88/classA.html">A</a></em> and <em>x</em>. </td></tr>
    <tr><td class="paramname">cols</td><td>Selected columns of <em><a class="el" href="../../d2/d88/classA.html">A</a></em> and <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The uniformized matrix is given by <img class="formulaInl" alt="$ (A/lambda + I) $" src="../../form_19.png"/>. </dd></dl>

</div>
</div>
<a id="ga96e76ef047bc21e64dbd5780921179e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga96e76ef047bc21e64dbd5780921179e3">&#9670;&nbsp;</a></span>prod_vec_invDiagM_M()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorIn , class VectorOut , class Matrix , class RowSelector , class ColSelector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; prod_vec_invDiagM_M </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>outVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorIn &amp;&#160;</td>
          <td class="paramname"><em>inVec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Vector * matrix product with discretization of <em>M:</em> <img class="formulaInl" alt="$ out += -in \cdot (diag^{-1}(M)) \times M $" src="../../form_21.png"/>. y must be a different vector than x. The diag operation is safe and works also with zero diagonals. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. </td></tr>
    <tr><td class="paramname">x</td><td>Vector factor. </td></tr>
    <tr><td class="paramname">M</td><td>Matrix factor. </td></tr>
    <tr><td class="paramname">rows</td><td>Rows of (y,<a class="el" href="../../d2/d88/classA.html">A</a>,x) selected for the computation. </td></tr>
    <tr><td class="paramname">cols</td><td>Columns of (y,<a class="el" href="../../d2/d88/classA.html">A</a>,x) selected for the computation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>

</div>
</div>
<a id="gac3e91ea9c1bd63130545bdfdc99f6946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3e91ea9c1bd63130545bdfdc99f6946">&#9670;&nbsp;</a></span>prod_vecmat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorX , class VectorOut , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; prod_vecmat </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorX &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fast vector * matrix product <img class="formulaInl" alt="$ y = x \cdot A $" src="../../form_2.png"/>. y must be a different vector than x </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. </td></tr>
    <tr><td class="paramname">x</td><td>Vector factor. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Matrix factor. </td></tr>
    <tr><td class="paramname">rows</td><td>Rows of (y,<a class="el" href="../../d2/d88/classA.html">A</a>,x) selected for the computation. </td></tr>
    <tr><td class="paramname">cols</td><td>Columns of (y,<a class="el" href="../../d2/d88/classA.html">A</a>,x) selected for the computation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>

</div>
</div>
<a id="ga6ced41adea05195b679fcb600b6edf35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ced41adea05195b679fcb600b6edf35">&#9670;&nbsp;</a></span>prod_vecmat_diag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorX , class VectorD , class VectorOut , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; prod_vecmat_diag </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorX &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorD &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fast vector * matrix product <img class="formulaInl" alt="$ y = x \cdot (A+Id) $" src="../../form_6.png"/>. <br />
y must be a different vector than x </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. </td></tr>
    <tr><td class="paramname">x</td><td>Vector factor. </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Matrix factor. </td></tr>
    <tr><td class="paramname">d</td><td>Diagonal vector added to <a class="el" href="../../d2/d88/classA.html">A</a> </td></tr>
    <tr><td class="paramname">rows</td><td>Rows of (y,<a class="el" href="../../d2/d88/classA.html">A</a>,d,x) selected for the computation. </td></tr>
    <tr><td class="paramname">cols</td><td>Columns of (y,<a class="el" href="../../d2/d88/classA.html">A</a>,d,x) selected for the computation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd><em><a class="el" href="../../d2/d88/classA.html">A</a></em> must be a N*N square matrix. Rectangular matrices are not supported </dd></dl>

</div>
</div>
<a id="gab9fd8cec43d936a584a6dba09b359559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9fd8cec43d936a584a6dba09b359559">&#9670;&nbsp;</a></span>prod_vecmat_unif()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorX , class VectorOut , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; prod_vecmat_unif </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorX &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply <em>x</em> with the uniformized matrix, and assign the result to <em>y:</em> <img class="formulaInl" alt="$ y = x * (A/lambda + I) $" src="../../form_18.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. Must be initialized. </td></tr>
    <tr><td class="paramname">x</td><td>Source vector multiplied with the uniformized matrix </td></tr>
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Non uniformized matrix. </td></tr>
    <tr><td class="paramname">lambda</td><td>Uniformization coefficient </td></tr>
    <tr><td class="paramname">rows</td><td>Selected rows of <em><a class="el" href="../../d2/d88/classA.html">A</a></em> and <em>x</em>. </td></tr>
    <tr><td class="paramname">cols</td><td>Selected columns of <em><a class="el" href="../../d2/d88/classA.html">A</a></em> and <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The uniformized matrix is given by <img class="formulaInl" alt="$ (A/lambda + I) $" src="../../form_19.png"/>. </dd></dl>

</div>
</div>
<a id="gaa761f5eb727fe6df3cb364b8172240c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa761f5eb727fe6df3cb364b8172240c5">&#9670;&nbsp;</a></span>project_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void project_matrix </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>inM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>outM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new (smaller) matrix <em>outM</em> which is the row/column projection of the input matrix. The size is rows.count() x cols.count() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inM</td><td>Input matrix. </td></tr>
    <tr><td class="paramname">outM</td><td>Output projected matrix. </td></tr>
    <tr><td class="paramname">rows</td><td>Projection rows. </td></tr>
    <tr><td class="paramname">cols</td><td>Projection columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3a2de70f0fcdfb3b41f9a5d4a77d6bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a2de70f0fcdfb3b41f9a5d4a77d6bf4">&#9670;&nbsp;</a></span>project_matrix_inv()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class RowSelector , class ColSelector , class InvColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void project_matrix_inv </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>inM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>outM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InvColSelector &amp;&#160;</td>
          <td class="paramname"><em>colsInv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new (smaller) matrix <em>outM</em> which is the row/column projection of the input matrix. The size is rows.count() x cols.count() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inM</td><td>Input matrix. </td></tr>
    <tr><td class="paramname">outM</td><td>Output projected matrix. </td></tr>
    <tr><td class="paramname">rows</td><td>Projection rows. </td></tr>
    <tr><td class="paramname">cols</td><td>Projection columns. </td></tr>
    <tr><td class="paramname">colsInv</td><td>Inverted projection columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga02656b2faaea43c0618182cdb114fb2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga02656b2faaea43c0618182cdb114fb2b">&#9670;&nbsp;</a></span>project_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorIn , class VectorOut , class Selector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void project_vector </td>
          <td>(</td>
          <td class="paramtype">const VectorIn &amp;&#160;</td>
          <td class="paramname"><em>inV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>outV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selector &amp;&#160;</td>
          <td class="paramname"><em>sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a new (smaller) vector <em>outV</em> which is the projection of the input vector. The new size is sel.count() </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inV</td><td>Input vector. </td></tr>
    <tr><td class="paramname">outV</td><td>Output vector. </td></tr>
    <tr><td class="paramname">sel</td><td>Projection elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaacbc8b1c21be576ebdabbe1bd087b19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaacbc8b1c21be576ebdabbe1bd087b19f">&#9670;&nbsp;</a></span>set_vec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorOut , class Selector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; set_vec </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign a constant to every vector elements: <img class="formulaInl" alt="$ y = c $" src="../../form_14.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. Must be initialized. </td></tr>
    <tr><td class="paramname">c</td><td>Assigned constant. </td></tr>
    <tr><td class="paramname">rows</td><td>Selected elements of <em>y</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>

</div>
</div>
<a id="gaf4dddab73b549fbd5da05074a25a6627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4dddab73b549fbd5da05074a25a6627">&#9670;&nbsp;</a></span>set_vec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorOut &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorOut&amp; set_vec </td>
          <td>(</td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assign a constant to every vector elements: <img class="formulaInl" alt="$ y = c $" src="../../form_14.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">y</td><td>Destination vector. Must be initialized. </td></tr>
    <tr><td class="paramname">c</td><td>Assigned constant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="../../d2/d88/classA.html">A</a> reference to the destination vector <em>y</em>. </dd></dl>

</div>
</div>
<a id="gae1bde3a28182d066e175ac16286d6b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1bde3a28182d066e175ac16286d6b84">&#9670;&nbsp;</a></span>Solve_SteadyState_CTMC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class Vector1 , class Vector2 , class Vector3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Solve_SteadyState_CTMC </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector1 &amp;&#160;</td>
          <td class="paramname"><em>sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>pi0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3 &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KolmogorovEquationDirection&#160;</td>
          <td class="paramname"><em>ked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d03/structSolverParams.html">SolverParams</a> &amp;&#160;</td>
          <td class="paramname"><em>spar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/dc9/classBSCC.html">BSCC</a> &amp;&#160;</td>
          <td class="paramname"><em>bscc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;&#160;</td>
          <td class="paramname"><em>printOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector1 *&#160;</td>
          <td class="paramname"><em>init_x0</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the Steady <a class="el" href="../../d7/d97/classState.html">State</a> solution of any <a class="el" href="../../dd/da6/structCTMC.html" title="Continuous-Time Markov Chain. ">CTMC</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>Infinitesimal generator matrix (ergodic or not). </td></tr>
    <tr><td class="paramname">sol</td><td>On return contains the solution vector. </td></tr>
    <tr><td class="paramname">pi0</td><td>Initial probability vector at time t=0. </td></tr>
    <tr><td class="paramname">rho</td><td>Backward boundary condition. </td></tr>
    <tr><td class="paramname">ked</td><td>Forward or backward solution. </td></tr>
    <tr><td class="paramname">spar</td><td>Method parameters. </td></tr>
    <tr><td class="paramname">bscc</td><td><a class="el" href="../../de/dc9/classBSCC.html" title="BSCC analysis of a Markov chain. ">BSCC</a> of the <em><a class="el" href="../../d2/d88/classA.html">A</a></em> Markov chain. </td></tr>
    <tr><td class="paramname">printOut</td><td>Print informations on the console. </td></tr>
    <tr><td class="paramname">init_x0</td><td>Initial distribution of x(0), (nullptr = uniform). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the solution has been found, false if the iterative method does not converge in maxIters iterations. </dd></dl>

</div>
</div>
<a id="ga585741407f370039e6a097d700cec97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga585741407f370039e6a097d700cec97d">&#9670;&nbsp;</a></span>Solve_SteadyState_DTMC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class Vector1 , class Vector2 , class Vector3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Solve_SteadyState_DTMC </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector1 &amp;&#160;</td>
          <td class="paramname"><em>sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector2 &amp;&#160;</td>
          <td class="paramname"><em>pi0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector3 &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KolmogorovEquationDirection&#160;</td>
          <td class="paramname"><em>ked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d03/structSolverParams.html">SolverParams</a> &amp;&#160;</td>
          <td class="paramname"><em>spar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/dc9/classBSCC.html">BSCC</a> &amp;&#160;</td>
          <td class="paramname"><em>bscc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;&#160;</td>
          <td class="paramname"><em>printOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector1 *&#160;</td>
          <td class="paramname"><em>init_x0</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the Steady <a class="el" href="../../d7/d97/classState.html">State</a> solution of any DTMC. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Probabilistic matrix (ergodic or not). </td></tr>
    <tr><td class="paramname">sol</td><td>On return contains the solution vector. </td></tr>
    <tr><td class="paramname">pi0</td><td>Initial probability vector at iteration t=0. </td></tr>
    <tr><td class="paramname">rho</td><td>Backward boundary condition. </td></tr>
    <tr><td class="paramname">ked</td><td>Forward or backward solution. </td></tr>
    <tr><td class="paramname">spar</td><td>Method parameters. </td></tr>
    <tr><td class="paramname">bscc</td><td><a class="el" href="../../de/dc9/classBSCC.html" title="BSCC analysis of a Markov chain. ">BSCC</a> of the <em><a class="el" href="../../d2/d88/classA.html">A</a></em> Markov chain. </td></tr>
    <tr><td class="paramname">printOut</td><td>Print informations on the console. </td></tr>
    <tr><td class="paramname">init_x0</td><td>Initial distribution of x(0), (nullptr = uniform). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the solution has been found, false if the iterative method does not converge in maxIters iterations. </dd></dl>

</div>
</div>
<a id="ga3c07ffe237fbd12e000434b4fff1cd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c07ffe237fbd12e000434b4fff1cd71">&#9670;&nbsp;</a></span>Solve_SteadyState_ErgodicCTMC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Solve_SteadyState_ErgodicCTMC </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KolmogorovEquationDirection&#160;</td>
          <td class="paramname"><em>ked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d03/structSolverParams.html">SolverParams</a> &amp;&#160;</td>
          <td class="paramname"><em>spar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;&#160;</td>
          <td class="paramname"><em>printOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector *&#160;</td>
          <td class="paramname"><em>init_x0</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the Steady <a class="el" href="../../d7/d97/classState.html">State</a> solution of an ergodic <a class="el" href="../../dd/da6/structCTMC.html" title="Continuous-Time Markov Chain. ">CTMC</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td>Infinitesimal generator matrix (must be ergodic). </td></tr>
    <tr><td class="paramname">sol</td><td>On return contains the solution vector. </td></tr>
    <tr><td class="paramname">ked</td><td>Forward or backward solution. </td></tr>
    <tr><td class="paramname">spar</td><td>Method parameters. </td></tr>
    <tr><td class="paramname">printOut</td><td>Print informations on the console. </td></tr>
    <tr><td class="paramname">init_x0</td><td>Initial distribution of x(0), (nullptr = uniform). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the solution has been found, false if the iterative method does not converge in maxIters iterations. </dd></dl>

</div>
</div>
<a id="ga1d2a1228628f7106eb7fb7f24fb3abc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d2a1228628f7106eb7fb7f24fb3abc3">&#9670;&nbsp;</a></span>Solve_SteadyState_ErgodicDTMC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class Vector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Solve_SteadyState_ErgodicDTMC </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector &amp;&#160;</td>
          <td class="paramname"><em>sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KolmogorovEquationDirection&#160;</td>
          <td class="paramname"><em>ked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d03/structSolverParams.html">SolverParams</a> &amp;&#160;</td>
          <td class="paramname"><em>spar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;&#160;</td>
          <td class="paramname"><em>printOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector *&#160;</td>
          <td class="paramname"><em>init_x0</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the Steady <a class="el" href="../../d7/d97/classState.html">State</a> solution of an ergodic DTMC. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">P</td><td>Probabilistic matrix (must be ergodic). </td></tr>
    <tr><td class="paramname">sol</td><td>On return contains the solution vector. </td></tr>
    <tr><td class="paramname">ked</td><td>Forward or backward solution. </td></tr>
    <tr><td class="paramname">spar</td><td>Method parameters. </td></tr>
    <tr><td class="paramname">printOut</td><td>Print informations on the console. </td></tr>
    <tr><td class="paramname">init_x0</td><td>Initial distribution of x(0), (nullptr = uniform). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the solution has been found, false if the iterative method does not converge in maxIters iterations. </dd></dl>

</div>
</div>
<a id="ga028ac6c84c1380e8b495c5463d18745c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga028ac6c84c1380e8b495c5463d18745c">&#9670;&nbsp;</a></span>Solve_SteadyState_ErgodicMC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorS , class VectorD , class VectorPi , class VectorRho &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Solve_SteadyState_ErgodicMC </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorS &amp;&#160;</td>
          <td class="paramname"><em>sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorD &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorPi &amp;&#160;</td>
          <td class="paramname"><em>pi0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorRho &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KolmogorovEquationDirection&#160;</td>
          <td class="paramname"><em>ked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d03/structSolverParams.html">SolverParams</a> &amp;&#160;</td>
          <td class="paramname"><em>spar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;&#160;</td>
          <td class="paramname"><em>printOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mcClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorS *&#160;</td>
          <td class="paramname"><em>init_x0</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the Steady <a class="el" href="../../d7/d97/classState.html">State</a> solution of an ergodic Markov Chain. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Markov chain matrix (must be ergodic). </td></tr>
    <tr><td class="paramname">d</td><td>Diagonal vector added to <em><a class="el" href="../../d2/d88/classA.html">A</a></em>. </td></tr>
    <tr><td class="paramname">sol</td><td>On return contains the solution vector. </td></tr>
    <tr><td class="paramname">pi0</td><td>Initial probability vector. </td></tr>
    <tr><td class="paramname">rho</td><td>Backward boundary condition. </td></tr>
    <tr><td class="paramname">ked</td><td>Forward or backward solution. </td></tr>
    <tr><td class="paramname">spar</td><td>Method parameters. </td></tr>
    <tr><td class="paramname">printOut</td><td>Print informations on the console. </td></tr>
    <tr><td class="paramname">mcClass</td><td>Name of the Markov Chain class of <em><a class="el" href="../../d2/d88/classA.html">A</a></em>. </td></tr>
    <tr><td class="paramname">init_x0</td><td>Initial distribution of x(0), (nullptr = uniform). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the solution has been found, false if the iterative method does not converge in maxIters iterations. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Steady state solutions are computed with the <img class="formulaInl" alt="$(A+Id)$" src="../../form_0.png"/> matrix. Therefore, set d=0 for CTMCs, and d=-1 for DTMCs. </dd></dl>

</div>
</div>
<a id="gab2bd253d95cc443d2e270937af60fb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2bd253d95cc443d2e270937af60fb2a">&#9670;&nbsp;</a></span>Solve_SteadyState_MC()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorS , class VectorPi , class VectorRho , class VectorD &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Solve_SteadyState_MC </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorS &amp;&#160;</td>
          <td class="paramname"><em>sol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorD &amp;&#160;</td>
          <td class="paramname"><em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorPi &amp;&#160;</td>
          <td class="paramname"><em>pi0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorRho &amp;&#160;</td>
          <td class="paramname"><em>rho</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KolmogorovEquationDirection&#160;</td>
          <td class="paramname"><em>ked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/d03/structSolverParams.html">SolverParams</a> &amp;&#160;</td>
          <td class="paramname"><em>spar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/dc9/classBSCC.html">BSCC</a> &amp;&#160;</td>
          <td class="paramname"><em>bscc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;&#160;</td>
          <td class="paramname"><em>printOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mcClass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorS *&#160;</td>
          <td class="paramname"><em>init_x0</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the Steady <a class="el" href="../../d7/d97/classState.html">State</a> solution of any Markov Chain. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname"><a class="el" href="../../d2/d88/classA.html">A</a></td><td>Markov chain matrix (may be reducible). </td></tr>
    <tr><td class="paramname">d</td><td>Diagonal vector added to <em><a class="el" href="../../d2/d88/classA.html">A</a></em>. </td></tr>
    <tr><td class="paramname">sol</td><td>On return contains the solution vector. </td></tr>
    <tr><td class="paramname">pi0</td><td>Initial probability vector at iteration t=0. </td></tr>
    <tr><td class="paramname">rho</td><td>Backward boundary condition. </td></tr>
    <tr><td class="paramname">ked</td><td>Forward or backward solution. </td></tr>
    <tr><td class="paramname">spar</td><td>Method parameters. </td></tr>
    <tr><td class="paramname">bscc</td><td><a class="el" href="../../de/dc9/classBSCC.html" title="BSCC analysis of a Markov chain. ">BSCC</a> of the <em><a class="el" href="../../d2/d88/classA.html">A</a></em> Markov chain. </td></tr>
    <tr><td class="paramname">printOut</td><td>Print informations on the console. </td></tr>
    <tr><td class="paramname">mcClass</td><td>Name of the Markov Chain class of <em><a class="el" href="../../d2/d88/classA.html">A</a></em>. </td></tr>
    <tr><td class="paramname">init_x0</td><td>Initial distribution of x(0), (nullptr = uniform). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the solution has been found, false if the iterative method does not converge in maxIters iterations. Steady state solutions are computed with the <img class="formulaInl" alt="$(A+Id)$" src="../../form_0.png"/> matrix. Therefore, set d=0 for CTMCs, and d=-1 for DTMCs. </dd></dl>

</div>
</div>
<a id="gad9c1b98b90c469d9a2ed08e8c9df5041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad9c1b98b90c469d9a2ed08e8c9df5041">&#9670;&nbsp;</a></span>TarjanIterative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">sccindex_t TarjanIterative </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; sccindex_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>SCC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterative version of Tarjan algorithm for finding the SCC in a sparse matrix, analyzed as an adjacency list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>The matrix graph. </td></tr>
    <tr><td class="paramname">SCC</td><td>On return contains the scc numbers for every node in mat </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of SCCs in the matrix graph. </dd></dl>

</div>
</div>
<a id="ga7412c545617e7b9559a780bcd3853ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7412c545617e7b9559a780bcd3853ead">&#9670;&nbsp;</a></span>UniformizationGen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class VectorIn , class VectorOut , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void UniformizationGen </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorIn &amp;&#160;</td>
          <td class="paramname"><em>pi0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>piExpQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorOut *&#160;</td>
          <td class="paramname"><em>p_piIntExpQ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KolmogorovEquationDirection&#160;</td>
          <td class="paramname"><em>ked</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dbd/classNullIterPrintOut.html">NullIterPrintOut</a> &amp;&#160;</td>
          <td class="paramname"><em>printOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>General Uniformization method. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Q</td><td><a class="el" href="../../dd/da6/structCTMC.html" title="Continuous-Time Markov Chain. ">CTMC</a>. </td></tr>
    <tr><td class="paramname">pi0</td><td>Initial distribution vector. </td></tr>
    <tr><td class="paramname">piExpQ</td><td>On return contains the transient solution at time t. </td></tr>
    <tr><td class="paramname">piIntExpQ</td><td>On return contains the cumulative probability. </td></tr>
    <tr><td class="paramname">fg</td><td>Probability density function of the general event. </td></tr>
    <tr><td class="paramname">epsilon</td><td>Max. relative error in the iterative method. </td></tr>
    <tr><td class="paramname">ked</td><td>Forward of backward uniformization </td></tr>
    <tr><td class="paramname">rows</td><td>Selected rows. </td></tr>
    <tr><td class="paramname">cols</td><td>Selected columns. </td></tr>
    <tr><td class="paramname">printOut</td><td>Print informations on the console. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga303361b96abf70839bc89feafd46df6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga303361b96abf70839bc89feafd46df6a">&#9670;&nbsp;</a></span>unproject_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix , class RowSelector , class ColSelector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void unproject_matrix </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>inM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>outM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>NC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RowSelector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ColSelector &amp;&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invert the matrix projection, by filling with zeroes the new elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inM</td><td>Input matrix. </td></tr>
    <tr><td class="paramname">outM</td><td>Output matrix. </td></tr>
    <tr><td class="paramname">NR</td><td>Output matrix rows. </td></tr>
    <tr><td class="paramname">NC</td><td>Output matrix columns. </td></tr>
    <tr><td class="paramname">rows</td><td>Projection rows. </td></tr>
    <tr><td class="paramname">cols</td><td>Projection columns. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga42afab68c14d7855367c02966b6a92c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42afab68c14d7855367c02966b6a92c8">&#9670;&nbsp;</a></span>unproject_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorIn , class VectorOut , class Selector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void unproject_vector </td>
          <td>(</td>
          <td class="paramtype">const VectorIn &amp;&#160;</td>
          <td class="paramname"><em>inV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorOut &amp;&#160;</td>
          <td class="paramname"><em>outV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selector &amp;&#160;</td>
          <td class="paramname"><em>sel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Invert the projection, by filling with zeroes the inserted elements. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inV</td><td>Input vector. </td></tr>
    <tr><td class="paramname">outV</td><td>Output vector. </td></tr>
    <tr><td class="paramname">N</td><td>Output vector dimension. </td></tr>
    <tr><td class="paramname">sel</td><td>Projection elements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c89d171bb83ffd0987b4b7599c0468a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c89d171bb83ffd0987b4b7599c0468a">&#9670;&nbsp;</a></span>vec_dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorIn1 , class VectorIn2 , class Selector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vec_dot </td>
          <td>(</td>
          <td class="paramtype">const VectorIn1 &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VectorIn2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Component dot-product: <img class="formulaInl" alt="$ c = x \cdot y $" src="../../form_17.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>First vector. Must be initialized. </td></tr>
    <tr><td class="paramname">y</td><td>Second vector. Must be initialized. </td></tr>
    <tr><td class="paramname">rows</td><td>Selected elements of . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The dot product of <em>x</em>. </dd></dl>

</div>
</div>
<a id="ga996678eec1bac1e1085dbe62da0cef6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga996678eec1bac1e1085dbe62da0cef6e">&#9670;&nbsp;</a></span>vec_sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorIn , class Selector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vec_sum </td>
          <td>(</td>
          <td class="paramtype">const VectorIn &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Selector &amp;&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Component sum: <img class="formulaInl" alt="$ c = \sum x_i $" src="../../form_16.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Source vector. Must be initialized. </td></tr>
    <tr><td class="paramname">rows</td><td>Selected elements of . </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The component sum of <em>x</em>. </dd></dl>

</div>
</div>
<a id="ga5878272da12d76146e9736f772ff2f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5878272da12d76146e9736f772ff2f0b">&#9670;&nbsp;</a></span>vec_sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VectorIn &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vec_sum </td>
          <td>(</td>
          <td class="paramtype">const VectorIn &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Component sum: <img class="formulaInl" alt="$ c = \sum x_i $" src="../../form_16.png"/>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Source vector. Must be initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The component sum of <em>x</em>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
